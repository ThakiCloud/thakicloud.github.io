---
title: "AI 시대의 소프트웨어: Andrej Karpathy가 말하는 3가지 프로그래밍 패러다임"
excerpt: "전 Tesla AI 디렉터 Andrej Karpathy의 통찰: Software 1.0에서 3.0까지, LLM을 운영체제로 보는 관점, 부분 자율성 앱의 미래, 그리고 모든 사람이 프로그래머가 되는 시대"
date: 2025-06-19
categories:
  - dev
tags:
  - Andrej Karpathy
  - Software Engineering
  - LLM
  - Programming Paradigms
  - AI Applications
  - Future of Coding
author_profile: true
toc: true
toc_label: 핵심 내용
---

<figure class="video-container">
  <iframe
    src="https://www.youtube.com/embed/LCEmiRjPEtQ"
    title="Software in the Era of AI - Andrej Karpathy"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
  ></iframe>
  <figcaption>※ 전체 발표 영상을 통해 Andrej Karpathy의 AI 시대 소프트웨어에 대한 완전한 인사이트를 확인할 수 있어요.</figcaption>
</figure>

## 한눈에 보는 핵심 메시지

- **소프트웨어가 70년 만에 근본적으로 변하고 있어요.** 최근 몇 년간 두 번의 급격한 변화가 일어났어요.
- **3가지 프로그래밍 패러다임이 공존해요**: Software 1.0(코드), 2.0(신경망 가중치), 3.0(영어 프롬프트)
- **LLM은 새로운 운영체제예요.** 유틸리티, 팹, 운영체제의 특성을 모두 가지고 있어요.
- **현재는 1960년대 컴퓨팅 시대와 비슷해요.** 중앙집중식 클라우드에서 시분할 방식으로 사용하고 있어요.
- **LLM은 "사람의 영혼"이에요.** 백과사전적 지식을 가졌지만 인지적 결함도 많아요.
- **부분 자율성 앱이 미래예요.** 완전 자율보다는 인간과 AI의 협업이 핵심이에요.
- **영어로 프로그래밍하는 시대가 왔어요.** 모든 사람이 프로그래머가 될 수 있어요.
- **에이전트를 위한 인프라 구축이 필요해요.** 새로운 디지털 정보 소비자가 등장했어요.

---

## 소프트웨어의 3가지 진화 단계

### Software 1.0: 전통적인 코딩
- **컴퓨터에게 직접 명령하는 코드**
- Python, JavaScript 등 프로그래밍 언어로 작성
- 70년간 변하지 않은 기본 패러다임

### Software 2.0: 신경망의 등장
- **신경망의 가중치가 곧 코드**
- 직접 코드를 작성하지 않고 데이터셋을 조정
- 옵티마이저가 신경망 파라미터를 생성
- Hugging Face = Software 2.0의 GitHub

### Software 3.0: LLM과 프롬프트 프로그래밍
- **영어 프롬프트로 LLM을 프로그래밍**
- 신경망이 프로그래밍 가능한 컴퓨터가 됨
- 자연어가 새로운 프로그래밍 언어

> **"우리는 이제 컴퓨터를 영어로 프로그래밍하고 있어요."**

## LLM을 운영체제로 보는 관점

### 유틸리티로서의 LLM
- **전력망과 유사한 구조**: LLM 랩들이 CAPEX로 모델 훈련, OPEX로 API 서비스 제공
- **미터링 방식**: 토큰당 과금
- **유틸리티 요구사항**: 낮은 지연시간, 높은 가동률, 일관된 품질
- **전환 스위치**: OpenRouter 같은 서비스로 LLM 간 전환 가능
- **지능 정전**: 최신 LLM들이 다운되면 전 세계가 일시적으로 "바보"가 됨

### 팹(Fab)으로서의 LLM
- **거대한 CAPEX 투자** 필요
- **빠르게 발전하는 기술 트리**와 R&D 비밀
- **팹리스 모델**: Nvidia GPU만 사용하는 경우
- **인텔 모델**: Google의 TPU처럼 자체 하드웨어까지 소유

### 운영체제로서의 LLM

가장 적절한 비유라고 Karpathy는 강조해요:

| 운영체제 요소 | LLM 대응 |
|---------------|----------|
| **CPU** | LLM 자체 |
| **메모리** | 컨텍스트 윈도우 |
| **앱 생태계** | 폐쇄형(GPT, Claude) vs 오픈소스(Llama) |
| **크로스 플랫폼** | Cursor가 GPT/Claude/Gemini에서 모두 실행 |

## LLM의 심리학: "사람의 영혼"

### 초인적 능력들
- **백과사전적 지식과 기억력**: 인터넷 전체 텍스트 학습
- **레인맨 같은 기억력**: 전화번호부를 통째로 기억하는 자폐 서번트와 유사

### 인지적 결함들
- **환각(Hallucination)**: 거짓 정보를 만들어냄
- **자기 인식 부족**: 내적 모델이 불완전
- **들쭉날쭉한 지능**: 어떤 영역은 초인적, 어떤 영역은 기본적 실수
  - 9.11 > 9.9라고 주장
  - "strawberry"에 R이 두 개 있다고 착각
- **전향성 기억상실**: 새로운 정보를 장기 기억으로 통합하지 못함

### 보안 취약점
- **속기 쉬움**: 프롬프트 인젝션 공격에 취약
- **데이터 유출 위험**
- **일관성 없는 행동**

> **"동료가 매일 아침 기억을 잃고 출근한다면 어떨지 상상해보세요. 바로 LLM의 현실이에요."**

## 부분 자율성 앱의 시대

### Cursor: 완벽한 LLM 앱 사례

**핵심 특징들**:
1. **컨텍스트 관리**: LLM이 복잡한 컨텍스트를 자동 처리
2. **다중 LLM 오케스트레이션**: 임베딩, 채팅, 코드 적용 모델들을 조합
3. **애플리케이션별 GUI**: 텍스트보다 직관적인 diff 표시
4. **자율성 슬라이더**: 탭 완성 → 코드 블록 변경 → 전체 파일 → 전체 저장소

### Perplexity: 검색의 재발명

**유사한 패턴**:
- 정보 패키징과 다중 LLM 조합
- 소스 인용으로 검증 가능한 GUI
- Quick Search → Research → Deep Research 자율성 레벨

### 성공하는 LLM 앱의 공통점

1. **생성은 AI, 검증은 인간**
2. **빠른 검증을 위한 GUI 최적화**
3. **AI를 목줄에 묶어두기**: 1만 줄 diff는 도움이 안 됨
4. **작은 단위로 점진적 작업**

## 모든 사람이 프로그래머가 되는 시대

### Vibe Coding의 등장

> **"갑자기 모든 사람이 프로그래머가 되었어요. 영어를 할 수 있으니까요."**

**Karpathy의 경험**:
- **iOS 앱**: Swift를 모르지만 하루 만에 앱 제작
- **Menu Generator**: 메뉴 사진을 찍으면 음식 이미지를 생성하는 앱

### Vibe Coding의 현실

**쉬운 부분**: 실제 코딩
**어려운 부분**: 실제 배포
- 인증, 결제, 도메인, 배포 설정
- 브라우저에서 클릭 작업들
- "컴퓨터가 나에게 클릭하라고 지시하는 게 말이 돼?"

## 에이전트를 위한 인프라 구축

### 새로운 디지털 정보 소비자

기존: **인간(GUI)** + **프로그램(API)**
새로운: **에이전트** (컴퓨터이지만 인간적 특성)

### 에이전트 친화적 인프라

**1. LLM.txt 파일**
- robots.txt와 유사한 개념
- LLM에게 도메인 정보를 직접 전달
- HTML 파싱보다 훨씬 정확

**2. 마크다운 문서화**
- **Vercel, Stripe** 등이 선도
- LLM이 이해하기 쉬운 형식
- "클릭"을 "curl 명령어"로 대체

**3. 도구들**
- **git-ingest**: GitHub → LLM 친화적 텍스트 변환
- **Deep Wiki**: Devon이 저장소 분석해서 문서 자동 생성

### Model Context Protocol
- Anthropic의 에이전트 전용 프로토콜
- 에이전트와 직접 소통하는 새로운 방식

## Tesla에서 배운 부분 자율성의 교훈

### 2013년 Waymo 완벽한 시연
- **30분간 무개입 완벽 주행**
- "자율주행이 임박했다!"고 생각
- **12년이 지난 지금도 여전히 개발 중**

### 자율성의 현실
- **완벽한 데모 ≠ 실제 제품**
- **텔레오퍼레이션과 인간 개입**이 여전히 필요
- **"2025년은 에이전트의 해"** → **"이번 10년이 에이전트의 10년"**

### Iron Man 슈트 vs Iron Man 로봇

**Iron Man 슈트** (추천):
- 토니 스타크가 착용하고 조종
- 인간 증강(Augmentation)
- 부분 자율성 제품

**Iron Man 로봇** (주의):
- 완전 자율 에이전트
- 화려한 데모용
- 아직은 시기상조

## 미래 전망: 자율성 슬라이더의 진화

### 향후 10년의 변화
- **왼쪽(인간 주도) → 오른쪽(AI 주도)**로 슬라이더 이동
- **점진적 자율성 증가**
- **인간과 AI의 협업 최적화**

### 개발자들이 해야 할 일

**1. 3가지 패러다임 모두 숙달**
- Software 1.0, 2.0, 3.0을 상황에 맞게 선택

**2. 부분 자율성 제품 구축**
- 생성-검증 루프 최적화
- 사용자 친화적 GUI 설계
- 자율성 슬라이더 구현

**3. 에이전트 친화적 인프라 구축**
- LLM이 이해하기 쉬운 문서화
- API와 GUI 사이의 새로운 인터페이스

---

### 마무리

> **"소프트웨어 업계에 입문하기에 이보다 더 흥미진진한 시기는 없었어요. 엄청난 양의 소프트웨어를 새로 작성하고 다시 작성해야 하거든요."**

Andrej Karpathy의 통찰은 명확해요. 우리는 컴퓨팅 역사상 가장 근본적인 변화의 한복판에 있어요. 70년간 변하지 않던 소프트웨어가 몇 년 사이에 두 번이나 급변했고, 이제 모든 사람이 영어로 컴퓨터를 프로그래밍할 수 있는 시대가 왔어요.

중요한 건 완전 자율 에이전트에 대한 과도한 기대보다는, 인간과 AI가 효과적으로 협업할 수 있는 부분 자율성 제품을 만드는 거예요. Tesla에서 12년간 자율주행을 개발한 경험이 보여주듯, 진정한 자율성은 시간이 걸리지만 부분 자율성은 지금 당장 엄청난 가치를 창출할 수 있어요.

**놓치지 말아야 할 한 문장**  
*Iron Man 로봇보다는 Iron Man 슈트를 만들어야 할 때예요.* 