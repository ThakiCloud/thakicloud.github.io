---
title: "Vibe Kanban ì™„ì „ ê°€ì´ë“œ - AI ì—ì´ì „íŠ¸ì™€ GitHub í”„ë¡œì íŠ¸ í†µí•© ìš´ì˜ë²•"
excerpt: "BloopAIì˜ Vibe Kanbanì„ í™œìš©í•˜ì—¬ AI ì½”ë”© ì—ì´ì „íŠ¸ë“¤ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê³ , ê¸°ì¡´ GitHub í”„ë¡œì íŠ¸ì™€ ì™„ë²½í•˜ê²Œ í†µí•©í•˜ëŠ” ë°©ë²•ì„ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤."
seo_title: "Vibe Kanban íŠœí† ë¦¬ì–¼ - AI ì—ì´ì „íŠ¸ í”„ë¡œì íŠ¸ ê´€ë¦¬ ì™„ì „ ê°€ì´ë“œ - Thaki Cloud"
seo_description: "BloopAI Vibe Kanbanìœ¼ë¡œ Claude Code, Gemini CLI ë“± AI ì—ì´ì „íŠ¸ë¥¼ ê´€ë¦¬í•˜ê³  GitHub í”„ë¡œì íŠ¸ì™€ í†µí•©í•˜ëŠ” ì‹¤ë¬´ ê°€ì´ë“œ. Apache-2.0 ë¼ì´ì„ ìŠ¤ ë¶„ì„ í¬í•¨."
date: 2025-07-17
last_modified_at: 2025-07-17
categories:
  - tutorials
  - agentops
tags:
  - Vibe-Kanban
  - BloopAI
  - AI-ì—ì´ì „íŠ¸
  - ì¹¸ë°˜ë³´ë“œ
  - Claude-Code
  - Gemini-CLI
  - í”„ë¡œì íŠ¸-ê´€ë¦¬
  - Apache-2.0
author_profile: true
toc: true
toc_label: "ëª©ì°¨"
toc_icon: "cog"
toc_sticky: true
canonical_url: "https://thakicloud.github.io/tutorials/vibe-kanban-ai-agents-project-management-guide/"
reading_time: true
---

â±ï¸ **ì˜ˆìƒ ì½ê¸° ì‹œê°„**: 18ë¶„

## ì„œë¡ 

**Vibe Kanban**ì€ BloopAIì—ì„œ ê°œë°œí•œ í˜ì‹ ì ì¸ AI ì—ì´ì „íŠ¸ ê´€ë¦¬ ë„êµ¬ë¡œ, Claude Code, Gemini CLI, Codex, Amp ë“± ë‹¤ì–‘í•œ AI ì½”ë”© ì—ì´ì „íŠ¸ë“¤ì„ ì¹¸ë°˜ ë³´ë“œ í˜•íƒœë¡œ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” í”Œë«í¼ì…ë‹ˆë‹¤.

ê¸°ì¡´ì˜ ë‹¨ìˆœí•œ í•  ì¼ ê´€ë¦¬ì™€ ë‹¬ë¦¬, Vibe Kanbanì€ **AI ì—ì´ì „íŠ¸ë“¤ ê°„ì˜ í˜‘ì—…ê³¼ ì‘ì—… íë¦„ì„ ì‹œê°í™”**í•˜ì—¬ ë³µì¡í•œ ê°œë°œ í”„ë¡œì íŠ¸ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤. íŠ¹íˆ GitHub í”„ë¡œì íŠ¸ì™€ì˜ ì™„ë²½í•œ í†µí•©ì„ í†µí•´ ì‹¤ì œ ê°œë°œ ì›Œí¬í”Œë¡œìš°ì— ìì—°ìŠ¤ëŸ½ê²Œ ë…¹ì•„ë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ ê°€ì´ë“œì—ì„œëŠ” Vibe Kanbanì˜ ì„¤ì¹˜ë¶€í„° ê³ ê¸‰ í™œìš©ë²•ê¹Œì§€, ê·¸ë¦¬ê³  ê¸°ì¡´ GitHub í”„ë¡œì íŠ¸ì™€ í•¨ê»˜ ìš´ì˜í•˜ëŠ” ì‹¤ë¬´ì ì¸ ë°©ë²•ë“¤ì„ ìƒì„¸íˆ ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤.

## ğŸ“„ ë¼ì´ì„ ìŠ¤ ë¶„ì„ ë° ìƒì—…ì  ì‚¬ìš© ê°€ëŠ¥ì„±

### Apache-2.0 ë¼ì´ì„ ìŠ¤ ê°œìš”

Vibe Kanbanì€ **Apache License 2.0**ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ëŠ” ë§¤ìš° ê´€ëŒ€í•œ ì˜¤í”ˆì†ŒìŠ¤ ë¼ì´ì„ ìŠ¤ë¡œ, ìƒì—…ì  í™œìš©ì— ëŒ€í•œ ì œì•½ì´ ê±°ì˜ ì—†ìŠµë‹ˆë‹¤.

### ìƒì—…ì  ì‚¬ìš© ê°€ëŠ¥ì„± ë§¤íŠ¸ë¦­ìŠ¤

| ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤ | í—ˆìš© ì—¬ë¶€ | ì†ŒìŠ¤ì½”ë“œ ê³µê°œ ì˜ë¬´ | ì¶”ê°€ ì¡°ê±´ |
|---------------|-----------|-------------------|-----------|
| **ê°œì¸ ì‚¬ìš©** | âœ… **ì™„ì „ í—ˆìš©** | âŒ **ë¶ˆí•„ìš”** | ì—†ìŒ |
| **ê¸°ì—… ë‚´ë¶€ ì‚¬ìš©** | âœ… **ì™„ì „ í—ˆìš©** | âŒ **ë¶ˆí•„ìš”** | ì—†ìŒ |
| **ìˆ˜ì • í›„ ë°°í¬** | âœ… **ì™„ì „ í—ˆìš©** | âŒ **ë¶ˆí•„ìš”** | ë¼ì´ì„ ìŠ¤ ê³ ì§€ë§Œ í•„ìš” |
| **ìƒìš© ì œí’ˆ ì„ë² ë”©** | âœ… **ì™„ì „ í—ˆìš©** | âŒ **ë¶ˆí•„ìš”** | ë¼ì´ì„ ìŠ¤ ê³ ì§€ë§Œ í•„ìš” |
| **í´ë¼ìš°ë“œ ì„œë¹„ìŠ¤** | âœ… **ì™„ì „ í—ˆìš©** | âŒ **ë¶ˆí•„ìš”** | ë¼ì´ì„ ìŠ¤ ê³ ì§€ë§Œ í•„ìš” |

### ğŸ¢ ê¸°ì—… í™˜ê²½ ê¶Œì¥ ì‚¬ìš© ë°©ì‹

```yaml
ê¶Œì¥ì‚¬í•­:
  ìƒì—…ì _ì‚¬ìš©: "ì™„ì „ ììœ  - ì–´ë–¤ ì œì•½ë„ ì—†ìŒ"
  ìˆ˜ì •_ë°°í¬: "ììœ ë¡­ê²Œ ê°€ëŠ¥"
  íŠ¹í—ˆ_ë³´í˜¸: "Apache-2.0 íŠ¹í—ˆ ë³´í˜¸ ì¡°í•­ ì ìš©"
  
ì¤€ìˆ˜ì‚¬í•­:
  ë¼ì´ì„ ìŠ¤_ê³ ì§€: "ë°°í¬ ì‹œ LICENSE íŒŒì¼ í¬í•¨"
  ì €ì‘ê¶Œ_í‘œì‹œ: "ì›ë³¸ ì €ì‘ê¶Œ ê³ ì§€ ìœ ì§€"
  ë³€ê²½ì‚¬í•­_í‘œì‹œ: "ìˆ˜ì • ì‚¬í•­ì´ ìˆë‹¤ë©´ NOTICE íŒŒì¼ì— ê¸°ë¡"
```

## ğŸš€ Vibe Kanban ì„¤ì¹˜ ë° í™˜ê²½ êµ¬ì„±

### ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­

#### ìµœì†Œ ìš”êµ¬ì‚¬í•­
```
- Node.js: 18.0+ 
- npm: 9.0+ ë˜ëŠ” yarn: 1.22+
- OS: Windows 10+, macOS 10.15+, Linux (Ubuntu 20.04+)
- RAM: 4GB ì´ìƒ
- ë””ìŠ¤í¬: 1GB ì—¬ìœ  ê³µê°„
```

#### ê¶Œì¥ ì‚¬ì–‘
```
- Node.js: 20.0+ (LTS)
- npm: 10.0+ ë˜ëŠ” yarn: 4.0+
- OS: ìµœì‹  ë²„ì „
- RAM: 8GB ì´ìƒ
- ë””ìŠ¤í¬: SSD ê¶Œì¥
```

### ë¹ ë¥¸ ì„¤ì¹˜ (npx ì‚¬ìš©)

#### 1. ì¦‰ì‹œ ì‹¤í–‰
```bash
# npxë¥¼ í†µí•œ ì¦‰ì‹œ ì‹¤í–‰
npx vibe-kanban

# íŠ¹ì • í¬íŠ¸ë¡œ ì‹¤í–‰
npx vibe-kanban --port 3001

# ì„¤ì • íŒŒì¼ ì§€ì •
npx vibe-kanban --config ./custom-config.json
```

#### 2. ì „ì—­ ì„¤ì¹˜
```bash
# npm ì „ì—­ ì„¤ì¹˜
npm install -g vibe-kanban

# yarn ì „ì—­ ì„¤ì¹˜
yarn global add vibe-kanban

# ì„¤ì¹˜ í™•ì¸
vibe-kanban --version

# ë„ì›€ë§ í™•ì¸
vibe-kanban --help
```

### í”„ë¡œì íŠ¸ë³„ ì„¤ì¹˜

#### 1. ê¸°ì¡´ í”„ë¡œì íŠ¸ì— ì¶”ê°€
```bash
# ê¸°ì¡´ í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¡œ ì´ë™
cd your-existing-project

# ê°œë°œ ì˜ì¡´ì„±ìœ¼ë¡œ ì„¤ì¹˜
npm install --save-dev vibe-kanban

# ë˜ëŠ” yarn ì‚¬ìš©
yarn add --dev vibe-kanban

# package.jsonì— ìŠ¤í¬ë¦½íŠ¸ ì¶”ê°€
cat >> package.json << 'EOF'
{
  "scripts": {
    "kanban": "vibe-kanban",
    "kanban:dev": "vibe-kanban --watch",
    "kanban:prod": "vibe-kanban --port 8080 --config production.json"
  }
}
EOF
```

#### 2. ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±
```bash
# ìƒˆ í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ìƒì„±
mkdir my-ai-project
cd my-ai-project

# npm í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
npm init -y

# Vibe Kanban ì„¤ì¹˜
npm install vibe-kanban

# ê¸°ë³¸ ì„¤ì • íŒŒì¼ ìƒì„±
npx vibe-kanban init
```

## âš™ï¸ ì„¤ì • ë° ì´ˆê¸° êµ¬ì„±

### ê¸°ë³¸ ì„¤ì • íŒŒì¼ ìƒì„±

#### 1. ì„¤ì • ë””ë ‰í† ë¦¬ êµ¬ì¡°
```bash
# í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— ì„¤ì • ë””ë ‰í† ë¦¬ ìƒì„±
mkdir -p .vibe-kanban/{agents,workflows,templates}

# ê¸°ë³¸ ì„¤ì • íŒŒì¼ ìƒì„±
cat > .vibe-kanban/config.json << 'EOF'
{
  "version": "1.0.0",
  "server": {
    "port": 3000,
    "host": "localhost",
    "cors": true
  },
  "agents": {
    "claude_code": {
      "enabled": true,
      "config_path": "./agents/claude-code.json"
    },
    "gemini_cli": {
      "enabled": true,
      "config_path": "./agents/gemini-cli.json"
    },
    "cursor": {
      "enabled": false,
      "config_path": "./agents/cursor.json"
    }
  },
  "workflows": {
    "default_board": "development",
    "auto_save": true,
    "sync_interval": 30
  },
  "github": {
    "integration": true,
    "webhook_url": "/api/github/webhook",
    "auto_create_tasks": true
  }
}
EOF
```

#### 2. AI ì—ì´ì „íŠ¸ ì„¤ì •
```json
# .vibe-kanban/agents/claude-code.json
{
  "name": "Claude Code",
  "type": "claude_code",
  "version": "1.0.0",
  "config": {
    "api_key_env": "ANTHROPIC_API_KEY",
    "model": "claude-3-5-sonnet-20241022",
    "max_tokens": 8192,
    "temperature": 0.1,
    "system_prompt": "You are a senior software engineer focused on writing clean, maintainable code.",
    "file_extensions": [".js", ".ts", ".py", ".go", ".rs"],
    "excluded_dirs": ["node_modules", ".git", "dist", "build"]
  },
  "capabilities": [
    "code_generation",
    "code_review",
    "debugging",
    "refactoring",
    "documentation"
  ],
  "workflow_hooks": {
    "pre_task": "analyze_context",
    "post_task": "validate_output",
    "on_error": "suggest_fix"
  }
}
```

```json
# .vibe-kanban/agents/gemini-cli.json
{
  "name": "Gemini CLI",
  "type": "gemini_cli",
  "version": "1.0.0",
  "config": {
    "api_key_env": "GEMINI_API_KEY",
    "model": "gemini-2.0-flash-exp",
    "max_output_tokens": 8192,
    "temperature": 0.2,
    "safety_settings": {
      "HARM_CATEGORY_HARASSMENT": "BLOCK_NONE",
      "HARM_CATEGORY_HATE_SPEECH": "BLOCK_NONE",
      "HARM_CATEGORY_SEXUALLY_EXPLICIT": "BLOCK_NONE",
      "HARM_CATEGORY_DANGEROUS_CONTENT": "BLOCK_NONE"
    }
  },
  "capabilities": [
    "multimodal_analysis",
    "image_generation",
    "code_explanation",
    "system_design"
  ],
  "workflow_hooks": {
    "pre_task": "load_context",
    "post_task": "save_artifacts"
  }
}
```

### ì›Œí¬í”Œë¡œìš° í…œí”Œë¦¿ ì„¤ì •

#### 1. ê°œë°œ ì›Œí¬í”Œë¡œìš° í…œí”Œë¦¿
```yaml
# .vibe-kanban/workflows/development.yaml
name: "Development Workflow"
description: "Standard software development workflow with AI agents"

boards:
  - name: "Backlog"
    description: "Ideas and future tasks"
    automation:
      - trigger: "new_github_issue"
        action: "create_task"
        agent: "claude_code"
        
  - name: "Planning"
    description: "Tasks being planned and analyzed"
    automation:
      - trigger: "task_moved_here"
        action: "analyze_requirements"
        agent: "claude_code"
        
  - name: "In Progress"
    description: "Currently being worked on"
    wip_limit: 3
    automation:
      - trigger: "task_moved_here"
        action: "start_coding"
        agent: "claude_code"
        
  - name: "Review"
    description: "Code review and quality check"
    automation:
      - trigger: "task_moved_here"
        action: "code_review"
        agent: "gemini_cli"
        
  - name: "Testing"
    description: "Testing and validation"
    automation:
      - trigger: "task_moved_here"
        action: "run_tests"
        agent: "claude_code"
        
  - name: "Done"
    description: "Completed tasks"
    automation:
      - trigger: "task_moved_here"
        action: "close_github_issue"
        
task_types:
  - name: "Feature"
    color: "#0066cc"
    estimated_time: "2-5 days"
    
  - name: "Bug Fix"
    color: "#cc0000"
    estimated_time: "1-2 days"
    
  - name: "Documentation"
    color: "#00cc66"
    estimated_time: "0.5-1 day"
    
  - name: "Refactoring"
    color: "#cc6600"
    estimated_time: "1-3 days"
```

#### 2. ë¦¬ì„œì¹˜ ì›Œí¬í”Œë¡œìš° í…œí”Œë¦¿
```yaml
# .vibe-kanban/workflows/research.yaml
name: "Research Workflow"
description: "AI-powered research and analysis workflow"

boards:
  - name: "Research Queue"
    description: "Topics to research"
    
  - name: "Data Collection"
    description: "Gathering information"
    automation:
      - trigger: "task_moved_here"
        action: "web_search"
        agent: "gemini_cli"
        
  - name: "Analysis"
    description: "Analyzing collected data"
    automation:
      - trigger: "task_moved_here"
        action: "analyze_data"
        agent: "claude_code"
        
  - name: "Documentation"
    description: "Creating research documentation"
    automation:
      - trigger: "task_moved_here"
        action: "create_report"
        agent: "claude_code"
        
  - name: "Published"
    description: "Completed research"
```

## ğŸ”— GitHub í”„ë¡œì íŠ¸ì™€ì˜ í†µí•©

### GitHub ì—°ë™ ì„¤ì •

#### 1. GitHub App ìƒì„± ë° ì„¤ì •
```bash
# GitHub CLI ì„¤ì¹˜ (macOS)
brew install gh

# GitHub CLI ì„¤ì¹˜ (Ubuntu)
sudo apt install gh

# GitHub ë¡œê·¸ì¸
gh auth login

# ìƒˆ GitHub App ìƒì„± (ì›¹ ì¸í„°í˜ì´ìŠ¤ì—ì„œ)
echo "GitHub App ìƒì„± ë‹¨ê³„:"
echo "1. https://github.com/settings/apps/new ì ‘ì†"
echo "2. App ì´ë¦„: 'Vibe Kanban Integration'"
echo "3. Homepage URL: http://localhost:3000"
echo "4. Webhook URL: http://localhost:3000/api/github/webhook"
echo "5. ê¶Œí•œ ì„¤ì •:"
echo "   - Issues: Read & Write"
echo "   - Pull requests: Read & Write"
echo "   - Repository contents: Read & Write"
echo "   - Repository metadata: Read"
```

#### 2. í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
```bash
# .env íŒŒì¼ ìƒì„±
cat > .env << 'EOF'
# AI ì—ì´ì „íŠ¸ API í‚¤
ANTHROPIC_API_KEY=your_anthropic_api_key_here
GEMINI_API_KEY=your_gemini_api_key_here
OPENAI_API_KEY=your_openai_api_key_here

# GitHub í†µí•©
GITHUB_TOKEN=your_github_token_here
GITHUB_APP_ID=your_github_app_id
GITHUB_PRIVATE_KEY_PATH=./github-app-private-key.pem
GITHUB_WEBHOOK_SECRET=your_webhook_secret

# Vibe Kanban ì„¤ì •
VIBE_KANBAN_PORT=3000
VIBE_KANBAN_HOST=localhost
VIBE_KANBAN_DB_PATH=./data/kanban.db
EOF

# .env íŒŒì¼ì„ .gitignoreì— ì¶”ê°€
echo ".env" >> .gitignore
echo "data/" >> .gitignore
echo ".vibe-kanban/cache/" >> .gitignore
```

#### 3. GitHub ì›¹í›… ì„¤ì •
```javascript
// .vibe-kanban/github-integration.js
const crypto = require('crypto');

class GitHubIntegration {
  constructor(config) {
    this.config = config;
    this.webhookSecret = process.env.GITHUB_WEBHOOK_SECRET;
  }

  verifyWebhookSignature(payload, signature) {
    const expectedSignature = crypto
      .createHmac('sha256', this.webhookSecret)
      .update(payload)
      .digest('hex');
    return `sha256=${expectedSignature}` === signature;
  }

  async handleWebhook(event, payload) {
    switch (event) {
      case 'issues':
        return this.handleIssueEvent(payload);
      case 'pull_request':
        return this.handlePullRequestEvent(payload);
      case 'push':
        return this.handlePushEvent(payload);
      default:
        console.log(`Unhandled webhook event: ${event}`);
    }
  }

  async handleIssueEvent(payload) {
    const { action, issue, repository } = payload;
    
    if (action === 'opened') {
      // ìƒˆ ì´ìŠˆê°€ ìƒì„±ë˜ë©´ ì¹¸ë°˜ ë³´ë“œì— íƒœìŠ¤í¬ ìƒì„±
      const task = {
        id: `github-issue-${issue.number}`,
        title: issue.title,
        description: issue.body,
        type: this.detectTaskType(issue.labels),
        priority: this.detectPriority(issue.labels),
        assignee: issue.assignee?.login,
        github_issue: {
          number: issue.number,
          url: issue.html_url,
          repository: repository.full_name
        },
        board: 'Backlog',
        created_at: new Date().toISOString()
      };
      
      return this.createKanbanTask(task);
    }
  }

  detectTaskType(labels) {
    const labelMap = {
      'bug': 'Bug Fix',
      'enhancement': 'Feature',
      'feature': 'Feature',
      'documentation': 'Documentation',
      'refactoring': 'Refactoring'
    };
    
    for (const label of labels) {
      if (labelMap[label.name.toLowerCase()]) {
        return labelMap[label.name.toLowerCase()];
      }
    }
    return 'Feature';
  }

  detectPriority(labels) {
    const priorityMap = {
      'priority: critical': 'Critical',
      'priority: high': 'High',
      'priority: medium': 'Medium',
      'priority: low': 'Low'
    };
    
    for (const label of labels) {
      if (priorityMap[label.name.toLowerCase()]) {
        return priorityMap[label.name.toLowerCase()];
      }
    }
    return 'Medium';
  }

  async createKanbanTask(task) {
    // Vibe Kanban APIë¥¼ í†µí•´ íƒœìŠ¤í¬ ìƒì„±
    const response = await fetch('http://localhost:3000/api/tasks', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.VIBE_KANBAN_API_TOKEN}`
      },
      body: JSON.stringify(task)
    });
    
    return response.json();
  }
}

module.exports = GitHubIntegration;
```

### í”„ë¡œì íŠ¸ êµ¬ì¡° í†µí•©

#### 1. ê¸°ì¡´ í”„ë¡œì íŠ¸ì™€ í†µí•©ëœ ë””ë ‰í† ë¦¬ êµ¬ì¡°
```
your-project/
â”œâ”€â”€ .vibe-kanban/              # Vibe Kanban ì„¤ì •
â”‚   â”œâ”€â”€ config.json            # ë©”ì¸ ì„¤ì •
â”‚   â”œâ”€â”€ agents/                # AI ì—ì´ì „íŠ¸ ì„¤ì •
â”‚   â”‚   â”œâ”€â”€ claude-code.json
â”‚   â”‚   â”œâ”€â”€ gemini-cli.json
â”‚   â”‚   â””â”€â”€ cursor.json
â”‚   â”œâ”€â”€ workflows/             # ì›Œí¬í”Œë¡œìš° ì •ì˜
â”‚   â”‚   â”œâ”€â”€ development.yaml
â”‚   â”‚   â”œâ”€â”€ research.yaml
â”‚   â”‚   â””â”€â”€ maintenance.yaml
â”‚   â”œâ”€â”€ templates/             # íƒœìŠ¤í¬ í…œí”Œë¦¿
â”‚   â”‚   â”œâ”€â”€ feature.json
â”‚   â”‚   â”œâ”€â”€ bugfix.json
â”‚   â”‚   â””â”€â”€ documentation.json
â”‚   â””â”€â”€ integrations/          # ì™¸ë¶€ í†µí•©
â”‚       â”œâ”€â”€ github.js
â”‚       â”œâ”€â”€ slack.js
â”‚       â””â”€â”€ jira.js
â”œâ”€â”€ src/                       # ê¸°ì¡´ ì†ŒìŠ¤ ì½”ë“œ
â”œâ”€â”€ docs/                      # ë¬¸ì„œ
â”œâ”€â”€ .github/                   # GitHub ì„¤ì •
â”‚   â”œâ”€â”€ workflows/             # GitHub Actions
â”‚   â”‚   â”œâ”€â”€ ci.yml
â”‚   â”‚   â””â”€â”€ vibe-kanban-sync.yml
â”‚   â””â”€â”€ ISSUE_TEMPLATE/        # ì´ìŠˆ í…œí”Œë¦¿
â”œâ”€â”€ package.json
â”œâ”€â”€ .env                       # í™˜ê²½ ë³€ìˆ˜
â””â”€â”€ .gitignore
```

#### 2. GitHub Actions ì›Œí¬í”Œë¡œìš° ì—°ë™
```yaml
# .github/workflows/vibe-kanban-sync.yml
name: Vibe Kanban Sync

on:
  issues:
    types: [opened, closed, labeled, unlabeled]
  pull_request:
    types: [opened, closed, merged]
  push:
    branches: [main, develop]

jobs:
  sync-kanban:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Start Vibe Kanban server
        run: |
          npm run kanban &
          sleep 10
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Sync with Kanban board
        run: node .vibe-kanban/scripts/github-sync.js
        env:
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
```

#### 3. ì´ìŠˆ í…œí”Œë¦¿ê³¼ Kanban ì—°ë™
```yaml
# .github/ISSUE_TEMPLATE/feature_request.yml
name: Feature Request
description: Suggest a new feature for this project
title: "[FEATURE] "
labels: ["enhancement", "priority: medium"]
assignees: []

body:
  - type: markdown
    attributes:
      value: |
        ## ğŸš€ Feature Request
        ì´ ì´ìŠˆëŠ” ìë™ìœ¼ë¡œ Vibe Kanban ë³´ë“œì— ì¶”ê°€ë©ë‹ˆë‹¤.

  - type: textarea
    id: description
    attributes:
      label: Feature Description
      description: ì›í•˜ëŠ” ê¸°ëŠ¥ì— ëŒ€í•´ ìì„¸íˆ ì„¤ëª…í•´ì£¼ì„¸ìš”.
      placeholder: ì´ ê¸°ëŠ¥ì´ ì–´ë–»ê²Œ ì‘ë™í•´ì•¼ í•˜ëŠ”ì§€ ì„¤ëª…í•´ì£¼ì„¸ìš”...
    validations:
      required: true

  - type: dropdown
    id: priority
    attributes:
      label: Priority
      description: ì´ ê¸°ëŠ¥ì˜ ìš°ì„ ìˆœìœ„ëŠ”?
      options:
        - Low
        - Medium
        - High
        - Critical
      default: 1
    validations:
      required: true

  - type: dropdown
    id: estimated_effort
    attributes:
      label: Estimated Effort
      description: ì˜ˆìƒ ì‘ì—… ì‹œê°„
      options:
        - "< 1 day"
        - "1-2 days"
        - "3-5 days"
        - "1-2 weeks"
        - "> 2 weeks"
      default: 2
    validations:
      required: true

  - type: checkboxes
    id: ai_agents
    attributes:
      label: AI Agents to Involve
      description: ì´ ì‘ì—…ì— ì°¸ì—¬í•  AI ì—ì´ì „íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”
      options:
        - label: Claude Code (ì½”ë“œ ìƒì„± ë° ë¦¬ë·°)
        - label: Gemini CLI (ë©€í‹°ëª¨ë‹¬ ë¶„ì„)
        - label: Cursor (í†µí•© ê°œë°œ í™˜ê²½)
```

## ğŸ¤– AI ì—ì´ì „íŠ¸ ì„¤ì • ë° ê´€ë¦¬

### ì—ì´ì „íŠ¸ë³„ ì„¸ë¶€ ì„¤ì •

#### 1. Claude Code ì—ì´ì „íŠ¸ ê³ ê¸‰ ì„¤ì •
```javascript
// .vibe-kanban/agents/claude-code-advanced.js
class ClaudeCodeAgent {
  constructor(config) {
    this.config = config;
    this.anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY
    });
  }

  async executeTask(task) {
    const context = await this.gatherContext(task);
    const prompt = this.buildPrompt(task, context);
    
    try {
      const response = await this.anthropic.messages.create({
        model: this.config.model,
        max_tokens: this.config.max_tokens,
        temperature: this.config.temperature,
        system: this.config.system_prompt,
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ]
      });

      const result = await this.processResponse(response, task);
      await this.updateTask(task.id, result);
      
      return result;
    } catch (error) {
      await this.handleError(task.id, error);
      throw error;
    }
  }

  async gatherContext(task) {
    const context = {
      project_structure: await this.getProjectStructure(),
      related_files: await this.getRelatedFiles(task),
      github_issue: await this.getGitHubIssue(task),
      recent_commits: await this.getRecentCommits(),
      test_files: await this.getTestFiles(task)
    };

    return context;
  }

  buildPrompt(task, context) {
    return `
# Task: ${task.title}

## Description
${task.description}

## Context
### Project Structure
${JSON.stringify(context.project_structure, null, 2)}

### Related Files
${context.related_files.map(file => `- ${file.path}: ${file.summary}`).join('\n')}

### GitHub Issue
${context.github_issue ? `
- Issue #${context.github_issue.number}: ${context.github_issue.title}
- Labels: ${context.github_issue.labels.map(l => l.name).join(', ')}
- Assignee: ${context.github_issue.assignee?.login || 'Unassigned'}
` : 'No associated GitHub issue'}

### Recent Commits
${context.recent_commits.map(commit => `- ${commit.sha.substring(0, 7)}: ${commit.message}`).join('\n')}

## Instructions
1. Analyze the task and context thoroughly
2. Create a detailed implementation plan
3. Generate clean, well-documented code
4. Include appropriate tests
5. Update relevant documentation
6. Follow the project's coding standards

## Expected Output
Please provide:
1. Implementation plan (in JSON format)
2. Code changes (with file paths)
3. Test cases
4. Documentation updates
5. Summary of changes

Format your response as a structured JSON object.
`;
  }

  async processResponse(response, task) {
    const content = response.content[0].text;
    
    try {
      const parsed = JSON.parse(content);
      
      // íŒŒì¼ ë³€ê²½ì‚¬í•­ ì ìš©
      if (parsed.code_changes) {
        for (const change of parsed.code_changes) {
          await this.applyFileChange(change);
        }
      }

      // í…ŒìŠ¤íŠ¸ ì‹¤í–‰
      if (parsed.test_cases) {
        const testResults = await this.runTests(parsed.test_cases);
        parsed.test_results = testResults;
      }

      // ë¬¸ì„œ ì—…ë°ì´íŠ¸
      if (parsed.documentation_updates) {
        await this.updateDocumentation(parsed.documentation_updates);
      }

      return parsed;
    } catch (error) {
      console.error('Failed to parse Claude Code response:', error);
      return {
        error: 'Failed to parse response',
        raw_response: content
      };
    }
  }

  async applyFileChange(change) {
    const fs = require('fs').promises;
    const path = require('path');
    
    try {
      if (change.action === 'create') {
        await fs.mkdir(path.dirname(change.path), { recursive: true });
        await fs.writeFile(change.path, change.content, 'utf8');
      } else if (change.action === 'modify') {
        await fs.writeFile(change.path, change.content, 'utf8');
      } else if (change.action === 'delete') {
        await fs.unlink(change.path);
      }
      
      console.log(`Applied ${change.action} to ${change.path}`);
    } catch (error) {
      console.error(`Failed to apply change to ${change.path}:`, error);
      throw error;
    }
  }
}

module.exports = ClaudeCodeAgent;
```

#### 2. Gemini CLI ì—ì´ì „íŠ¸ ì„¤ì •
```javascript
// .vibe-kanban/agents/gemini-cli-advanced.js
class GeminiCLIAgent {
  constructor(config) {
    this.config = config;
    this.gemini = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
  }

  async executeTask(task) {
    const model = this.gemini.getGenerativeModel({ 
      model: this.config.model,
      generationConfig: {
        maxOutputTokens: this.config.max_output_tokens,
        temperature: this.config.temperature
      },
      safetySettings: this.config.safety_settings
    });

    const context = await this.gatherMultimodalContext(task);
    const prompt = this.buildMultimodalPrompt(task, context);

    try {
      const result = await model.generateContent(prompt);
      const processed = await this.processMultimodalResponse(result, task);
      await this.updateTask(task.id, processed);
      
      return processed;
    } catch (error) {
      await this.handleError(task.id, error);
      throw error;
    }
  }

  async gatherMultimodalContext(task) {
    const context = {
      text_context: await this.getTextContext(task),
      images: await this.getRelatedImages(task),
      diagrams: await this.getSystemDiagrams(task),
      screenshots: await this.getScreenshots(task)
    };

    return context;
  }

  buildMultimodalPrompt(task, context) {
    const promptParts = [
      {
        text: `
# Multimodal Task Analysis: ${task.title}

## Task Description
${task.description}

## Analysis Instructions
1. Analyze all provided visual materials
2. Extract key information from images/diagrams
3. Correlate visual information with text context
4. Provide comprehensive analysis and recommendations
5. Generate visual artifacts if needed

## Text Context
${JSON.stringify(context.text_context, null, 2)}
`
      }
    ];

    // ì´ë¯¸ì§€ ì¶”ê°€
    if (context.images.length > 0) {
      promptParts.push({ text: "\n## Related Images" });
      context.images.forEach((image, index) => {
        promptParts.push({
          inlineData: {
            mimeType: image.mimeType,
            data: image.data
          }
        });
        promptParts.push({ text: `Image ${index + 1}: ${image.description}` });
      });
    }

    // ë‹¤ì´ì–´ê·¸ë¨ ì¶”ê°€
    if (context.diagrams.length > 0) {
      promptParts.push({ text: "\n## System Diagrams" });
      context.diagrams.forEach((diagram, index) => {
        promptParts.push({
          inlineData: {
            mimeType: diagram.mimeType,
            data: diagram.data
          }
        });
        promptParts.push({ text: `Diagram ${index + 1}: ${diagram.description}` });
      });
    }

    return promptParts;
  }

  async processMultimodalResponse(result, task) {
    const response = result.response.text();
    
    try {
      // êµ¬ì¡°í™”ëœ ì‘ë‹µ íŒŒì‹±
      const sections = this.parseResponseSections(response);
      
      // ì´ë¯¸ì§€ ìƒì„±ì´ í•„ìš”í•œ ê²½ìš°
      if (sections.generate_images) {
        const generatedImages = await this.generateImages(sections.generate_images);
        sections.generated_artifacts = generatedImages;
      }

      // ë‹¤ì´ì–´ê·¸ë¨ ìƒì„±ì´ í•„ìš”í•œ ê²½ìš°
      if (sections.generate_diagrams) {
        const diagrams = await this.generateDiagrams(sections.generate_diagrams);
        sections.generated_diagrams = diagrams;
      }

      return {
        analysis: sections.analysis,
        recommendations: sections.recommendations,
        generated_artifacts: sections.generated_artifacts || [],
        generated_diagrams: sections.generated_diagrams || [],
        raw_response: response
      };
    } catch (error) {
      console.error('Failed to process Gemini response:', error);
      return {
        error: 'Failed to process multimodal response',
        raw_response: response
      };
    }
  }
}

module.exports = GeminiCLIAgent;
```

### ì—ì´ì „íŠ¸ ê°„ í˜‘ì—… ì›Œí¬í”Œë¡œìš°

#### 1. ì—ì´ì „íŠ¸ ì²´ì¸ ì„¤ì •
```yaml
# .vibe-kanban/workflows/agent-chains.yaml
agent_chains:
  feature_development:
    name: "Feature Development Chain"
    description: "Complete feature development with multiple AI agents"
    steps:
      - agent: "gemini_cli"
        task: "analyze_requirements"
        inputs: ["github_issue", "user_stories"]
        outputs: ["requirements_analysis", "system_design"]
        
      - agent: "claude_code"
        task: "implement_feature"
        inputs: ["requirements_analysis", "system_design", "existing_codebase"]
        outputs: ["implementation", "unit_tests"]
        depends_on: ["analyze_requirements"]
        
      - agent: "gemini_cli"
        task: "review_implementation"
        inputs: ["implementation", "requirements_analysis"]
        outputs: ["code_review", "improvement_suggestions"]
        depends_on: ["implement_feature"]
        
      - agent: "claude_code"
        task: "apply_improvements"
        inputs: ["implementation", "improvement_suggestions"]
        outputs: ["final_implementation", "integration_tests"]
        depends_on: ["review_implementation"]
        
      - agent: "gemini_cli"
        task: "create_documentation"
        inputs: ["final_implementation", "requirements_analysis"]
        outputs: ["user_documentation", "technical_documentation"]
        depends_on: ["apply_improvements"]

  bug_fix:
    name: "Bug Fix Chain"
    description: "Systematic bug fixing with AI agents"
    steps:
      - agent: "gemini_cli"
        task: "analyze_bug_report"
        inputs: ["github_issue", "error_logs", "screenshots"]
        outputs: ["bug_analysis", "reproduction_steps"]
        
      - agent: "claude_code"
        task: "investigate_code"
        inputs: ["bug_analysis", "codebase", "test_results"]
        outputs: ["root_cause_analysis", "fix_proposal"]
        depends_on: ["analyze_bug_report"]
        
      - agent: "claude_code"
        task: "implement_fix"
        inputs: ["fix_proposal", "root_cause_analysis"]
        outputs: ["bug_fix", "regression_tests"]
        depends_on: ["investigate_code"]
        
      - agent: "gemini_cli"
        task: "validate_fix"
        inputs: ["bug_fix", "reproduction_steps", "test_results"]
        outputs: ["validation_report", "closure_recommendation"]
        depends_on: ["implement_fix"]
```

#### 2. ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì—”ì§„
```javascript
// .vibe-kanban/workflow-engine.js
class WorkflowEngine {
  constructor() {
    this.agents = new Map();
    this.workflows = new Map();
    this.activeExecutions = new Map();
  }

  registerAgent(name, agent) {
    this.agents.set(name, agent);
  }

  loadWorkflow(workflowConfig) {
    this.workflows.set(workflowConfig.name, workflowConfig);
  }

  async executeWorkflow(workflowName, initialInputs, taskId) {
    const workflow = this.workflows.get(workflowName);
    if (!workflow) {
      throw new Error(`Workflow not found: ${workflowName}`);
    }

    const execution = {
      id: `exec_${Date.now()}`,
      workflow: workflowName,
      taskId: taskId,
      status: 'running',
      steps: new Map(),
      outputs: new Map(),
      startTime: new Date(),
      currentStep: 0
    };

    this.activeExecutions.set(execution.id, execution);

    try {
      const result = await this.runWorkflowSteps(workflow, initialInputs, execution);
      execution.status = 'completed';
      execution.endTime = new Date();
      execution.result = result;
      
      await this.notifyWorkflowCompletion(execution);
      return result;
    } catch (error) {
      execution.status = 'failed';
      execution.error = error.message;
      execution.endTime = new Date();
      
      await this.notifyWorkflowError(execution, error);
      throw error;
    }
  }

  async runWorkflowSteps(workflow, inputs, execution) {
    const stepResults = new Map();
    const stepOutputs = new Map();
    
    // ì´ˆê¸° ì…ë ¥ ì„¤ì •
    stepOutputs.set('initial', inputs);

    for (const step of workflow.steps) {
      execution.currentStep++;
      
      // ì˜ì¡´ì„± ì²´í¬
      if (step.depends_on) {
        for (const dependency of step.depends_on) {
          if (!stepResults.has(dependency)) {
            throw new Error(`Dependency not satisfied: ${dependency}`);
          }
        }
      }

      // ì…ë ¥ ì¤€ë¹„
      const stepInputs = this.prepareStepInputs(step, stepOutputs);
      
      // ì—ì´ì „íŠ¸ ì‹¤í–‰
      const agent = this.agents.get(step.agent);
      if (!agent) {
        throw new Error(`Agent not found: ${step.agent}`);
      }

      console.log(`Executing step: ${step.task} with agent: ${step.agent}`);
      
      const stepResult = await agent.executeTask({
        id: `${execution.id}_${step.task}`,
        title: step.task,
        description: `Workflow step: ${step.task}`,
        inputs: stepInputs,
        workflow_context: {
          execution_id: execution.id,
          step_number: execution.currentStep,
          workflow_name: workflow.name
        }
      });

      stepResults.set(step.task, stepResult);
      stepOutputs.set(step.task, this.extractStepOutputs(stepResult, step.outputs));
      
      // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
      await this.updateWorkflowProgress(execution, stepResult);
    }

    return {
      steps: Object.fromEntries(stepResults),
      final_outputs: Object.fromEntries(stepOutputs)
    };
  }

  prepareStepInputs(step, stepOutputs) {
    const inputs = {};
    
    for (const inputName of step.inputs) {
      // ì´ì „ ìŠ¤í…ë“¤ì˜ ì¶œë ¥ì—ì„œ ì…ë ¥ ì°¾ê¸°
      for (const [stepName, outputs] of stepOutputs) {
        if (outputs[inputName]) {
          inputs[inputName] = outputs[inputName];
          break;
        }
      }
    }

    return inputs;
  }

  async updateWorkflowProgress(execution, stepResult) {
    // Kanban ë³´ë“œì— ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
    await fetch(`http://localhost:3000/api/tasks/${execution.taskId}/progress`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        workflow_progress: {
          execution_id: execution.id,
          current_step: execution.currentStep,
          status: execution.status,
          step_result: stepResult
        }
      })
    });
  }
}

module.exports = WorkflowEngine;
```

## ğŸ“Š ì‹¤ì œ ì‚¬ìš© ì‚¬ë¡€ ë° í™œìš©ë²•

### ì‚¬ìš© ì‚¬ë¡€ 1: ìƒˆë¡œìš´ ê¸°ëŠ¥ ê°œë°œ

#### 1. GitHub ì´ìŠˆ ìƒì„±ë¶€í„° ì™„ë£Œê¹Œì§€
```bash
#!/bin/bash
# feature-development-example.sh

echo "ğŸš€ Vibe Kanbanì„ í™œìš©í•œ ê¸°ëŠ¥ ê°œë°œ ì‹œë‚˜ë¦¬ì˜¤"

# 1. GitHub ì´ìŠˆ ìƒì„±
gh issue create \
  --title "[FEATURE] ì‚¬ìš©ì í”„ë¡œí•„ ì´ë¯¸ì§€ ì—…ë¡œë“œ ê¸°ëŠ¥" \
  --body "ì‚¬ìš©ìê°€ í”„ë¡œí•„ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ê³  í¬ë¡­í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ í•„ìš”í•©ë‹ˆë‹¤.

## ìš”êµ¬ì‚¬í•­
- ì´ë¯¸ì§€ íŒŒì¼ ì—…ë¡œë“œ (jpg, png, gif)
- ì‹¤ì‹œê°„ ì´ë¯¸ì§€ í¬ë¡­ ê¸°ëŠ¥
- ì¸ë„¤ì¼ ìë™ ìƒì„±
- íŒŒì¼ í¬ê¸° ìµœì í™”

## ê¸°ìˆ  ìŠ¤íƒ
- React.js (í”„ë¡ íŠ¸ì—”ë“œ)
- Node.js + Express (ë°±ì—”ë“œ)
- Sharp.js (ì´ë¯¸ì§€ ì²˜ë¦¬)
- AWS S3 (íŒŒì¼ ì €ì¥)

## ì¶”ì • ì‘ì—… ì‹œê°„
3-5ì¼" \
  --label "enhancement,priority: high" \
  --assignee $(gh api user --jq .login)

echo "âœ… GitHub ì´ìŠˆ ìƒì„± ì™„ë£Œ"

# 2. Vibe Kanbanì—ì„œ ìë™ìœ¼ë¡œ íƒœìŠ¤í¬ ìƒì„±ë¨ (ì›¹í›…ì„ í†µí•´)
echo "â³ Vibe Kanban ë³´ë“œì— íƒœìŠ¤í¬ ìë™ ìƒì„± ì¤‘..."
sleep 2

# 3. Claude Codeê°€ ìš”êµ¬ì‚¬í•­ ë¶„ì„ ì‹œì‘
echo "ğŸ¤– Claude Code: ìš”êµ¬ì‚¬í•­ ë¶„ì„ ì‹œì‘"
curl -X POST http://localhost:3000/api/tasks/github-issue-123/execute \
  -H "Content-Type: application/json" \
  -d '{
    "agent": "claude_code",
    "action": "analyze_requirements",
    "context": {
      "github_issue": 123,
      "priority": "high"
    }
  }'

# 4. Gemini CLIê°€ UI/UX ë””ìì¸ ë¶„ì„
echo "ğŸ¨ Gemini CLI: UI/UX ë””ìì¸ ë¶„ì„"
curl -X POST http://localhost:3000/api/tasks/github-issue-123/execute \
  -H "Content-Type: application/json" \
  -d '{
    "agent": "gemini_cli",
    "action": "design_analysis",
    "context": {
      "feature_type": "image_upload",
      "ui_patterns": ["crop", "drag_drop", "preview"]
    }
  }'

echo "ğŸ¯ ê¸°ëŠ¥ ê°œë°œ ì›Œí¬í”Œë¡œìš°ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!"
echo "ğŸ“Š ì§„í–‰ ìƒí™©ì€ http://localhost:3000ì—ì„œ í™•ì¸í•˜ì„¸ìš”."
```

#### 2. ì‹¤ì‹œê°„ ì§„í–‰ ìƒí™© ëª¨ë‹ˆí„°ë§
```javascript
// monitoring-dashboard.js
class KanbanMonitoring {
  constructor() {
    this.ws = new WebSocket('ws://localhost:3000/ws');
    this.setupEventListeners();
  }

  setupEventListeners() {
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleRealtimeUpdate(data);
    };
  }

  handleRealtimeUpdate(data) {
    switch (data.type) {
      case 'task_moved':
        this.updateTaskPosition(data.task);
        break;
      case 'agent_started':
        this.showAgentActivity(data.agent, data.task);
        break;
      case 'agent_completed':
        this.showAgentResults(data.agent, data.results);
        break;
      case 'workflow_progress':
        this.updateWorkflowProgress(data.workflow, data.progress);
        break;
    }
  }

  updateTaskPosition(task) {
    const taskElement = document.getElementById(`task-${task.id}`);
    const newBoard = document.getElementById(`board-${task.board}`);
    
    // ì‹œê°ì  íš¨ê³¼ì™€ í•¨ê»˜ íƒœìŠ¤í¬ ì´ë™
    taskElement.style.transform = 'scale(1.05)';
    taskElement.style.transition = 'all 0.3s ease';
    
    setTimeout(() => {
      newBoard.appendChild(taskElement);
      taskElement.style.transform = 'scale(1)';
    }, 150);
  }

  showAgentActivity(agent, task) {
    const notification = document.createElement('div');
    notification.className = 'agent-notification';
    notification.innerHTML = `
      <div class="agent-avatar">
        <img src="/agents/${agent.name}/avatar.png" alt="${agent.name}">
      </div>
      <div class="agent-message">
        <strong>${agent.name}</strong>ì´ ì‘ì—…ì„ ì‹œì‘í–ˆìŠµë‹ˆë‹¤: 
        <em>${task.title}</em>
      </div>
    `;
    
    document.getElementById('notifications').appendChild(notification);
    
    // 3ì´ˆ í›„ ìë™ ì œê±°
    setTimeout(() => notification.remove(), 3000);
  }
}

// ëª¨ë‹ˆí„°ë§ ì‹œì‘
const monitoring = new KanbanMonitoring();
```

### ì‚¬ìš© ì‚¬ë¡€ 2: ë²„ê·¸ ìˆ˜ì • ì›Œí¬í”Œë¡œìš°

#### 1. ë²„ê·¸ ë¦¬í¬íŠ¸ë¶€í„° ìˆ˜ì •ê¹Œì§€
```python
# bug-fix-automation.py
import requests
import json
from datetime import datetime

class BugFixAutomation:
    def __init__(self):
        self.kanban_api = "http://localhost:3000/api"
        self.github_api = "https://api.github.com"
        
    def handle_bug_report(self, issue_data):
        """ë²„ê·¸ ë¦¬í¬íŠ¸ ì²˜ë¦¬"""
        bug_task = {
            "id": f"bug-{issue_data['number']}",
            "title": f"ğŸ› {issue_data['title']}",
            "description": issue_data['body'],
            "type": "Bug Fix",
            "priority": self.detect_severity(issue_data['body']),
            "github_issue": issue_data['number'],
            "board": "Backlog",
            "created_at": datetime.now().isoformat(),
            "labels": [label['name'] for label in issue_data['labels']]
        }
        
        # Kanban ë³´ë“œì— íƒœìŠ¤í¬ ìƒì„±
        response = requests.post(
            f"{self.kanban_api}/tasks",
            json=bug_task
        )
        
        if response.status_code == 201:
            # Gemini CLIë¡œ ë²„ê·¸ ë¶„ì„ ì‹œì‘
            self.start_bug_analysis(bug_task['id'])
            
        return response.json()
    
    def detect_severity(self, description):
        """ë²„ê·¸ ì„¤ëª…ì—ì„œ ì‹¬ê°ë„ ì¶”ì¶œ"""
        critical_keywords = ['crash', 'data loss', 'security', 'critical']
        high_keywords = ['error', 'exception', 'fails', 'broken']
        
        description_lower = description.lower()
        
        if any(keyword in description_lower for keyword in critical_keywords):
            return "Critical"
        elif any(keyword in description_lower for keyword in high_keywords):
            return "High"
        else:
            return "Medium"
    
    def start_bug_analysis(self, task_id):
        """Gemini CLIë¡œ ë²„ê·¸ ë¶„ì„ ì‹œì‘"""
        analysis_request = {
            "agent": "gemini_cli",
            "action": "analyze_bug_report",
            "context": {
                "include_logs": True,
                "include_screenshots": True,
                "analyze_patterns": True
            }
        }
        
        response = requests.post(
            f"{self.kanban_api}/tasks/{task_id}/execute",
            json=analysis_request
        )
        
        if response.status_code == 200:
            print(f"âœ… ë²„ê·¸ ë¶„ì„ ì‹œì‘: {task_id}")
            # ë¶„ì„ ì™„ë£Œ í›„ Claude Codeë¡œ ìˆ˜ì • ì‘ì—… ì „ë‹¬
            self.schedule_bug_fix(task_id)
    
    def schedule_bug_fix(self, task_id):
        """Claude Codeë¡œ ë²„ê·¸ ìˆ˜ì • ìŠ¤ì¼€ì¤„ë§"""
        fix_request = {
            "agent": "claude_code",
            "action": "implement_bug_fix",
            "context": {
                "run_tests": True,
                "create_regression_tests": True,
                "update_documentation": True
            },
            "depends_on": ["analyze_bug_report"]
        }
        
        response = requests.post(
            f"{self.kanban_api}/tasks/{task_id}/schedule",
            json=fix_request
        )
        
        return response.json()

# ì‚¬ìš© ì˜ˆì œ
automation = BugFixAutomation()

# ì›¹í›…ì—ì„œ ë°›ì€ GitHub ì´ìŠˆ ë°ì´í„°
github_issue = {
    "number": 456,
    "title": "ì‚¬ìš©ì ë¡œê·¸ì¸ ì‹œ ì„¸ì…˜ ë§Œë£Œ ì˜¤ë¥˜",
    "body": """
## ë²„ê·¸ ì„¤ëª…
ì‚¬ìš©ìê°€ ë¡œê·¸ì¸í•œ í›„ 5ë¶„ ì´ë‚´ì— ì„¸ì…˜ì´ ì„ì˜ë¡œ ë§Œë£Œë˜ëŠ” ë¬¸ì œê°€ ë°œìƒí•©ë‹ˆë‹¤.

## ì¬í˜„ ë‹¨ê³„
1. ì‚¬ìš©ì ë¡œê·¸ì¸
2. ëŒ€ì‹œë³´ë“œ í˜ì´ì§€ ì´ë™
3. 5ë¶„ ëŒ€ê¸°
4. ì•„ë¬´ ë²„íŠ¼ì´ë‚˜ í´ë¦­

## ì˜ˆìƒ ê²°ê³¼
ì„¸ì…˜ì´ ìœ ì§€ë˜ì–´ì•¼ í•¨

## ì‹¤ì œ ê²°ê³¼
"ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤" ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ

## í™˜ê²½
- Browser: Chrome 120.0
- OS: Windows 11
- Version: v2.1.3
    """,
    "labels": [
        {"name": "bug"},
        {"name": "priority: high"},
        {"name": "authentication"}
    ]
}

result = automation.handle_bug_report(github_issue)
print(f"ë²„ê·¸ ì²˜ë¦¬ ê²°ê³¼: {result}")
```

### ì‚¬ìš© ì‚¬ë¡€ 3: ì—°êµ¬ ë° ë¬¸ì„œí™” í”„ë¡œì íŠ¸

#### 1. AI ì—ì´ì „íŠ¸ ê¸°ë°˜ ë¦¬ì„œì¹˜ ì›Œí¬í”Œë¡œìš°
```yaml
# research-workflow-example.yaml
name: "AI Research Project"
description: "AI ì—ì´ì „íŠ¸ë“¤ì„ í™œìš©í•œ ê¸°ìˆ  ë¦¬ì„œì¹˜ ë° ë¬¸ì„œí™”"

research_pipeline:
  - stage: "Topic Analysis"
    agent: "gemini_cli"
    tasks:
      - "ì‹œì¥ ë™í–¥ ë¶„ì„"
      - "ê²½ìŸì‚¬ ê¸°ìˆ  ì¡°ì‚¬"
      - "ì‚¬ìš©ì ë‹ˆì¦ˆ íŒŒì•…"
    outputs:
      - "market_analysis.md"
      - "competitor_report.md"
      - "user_requirements.md"
      
  - stage: "Technical Deep Dive"
    agent: "claude_code"
    tasks:
      - "ê¸°ìˆ  ìŠ¤íƒ ë¶„ì„"
      - "ì•„í‚¤í…ì²˜ ì„¤ê³„"
      - "êµ¬í˜„ ê°€ëŠ¥ì„± ê²€í† "
    inputs:
      - "market_analysis.md"
      - "user_requirements.md"
    outputs:
      - "tech_stack_analysis.md"
      - "architecture_design.md"
      - "feasibility_report.md"
      
  - stage: "Prototype Development"
    agent: "claude_code"
    tasks:
      - "í”„ë¡œí† íƒ€ì… ì½”ë“œ ì‘ì„±"
      - "ë°ëª¨ ì• í”Œë¦¬ì¼€ì´ì…˜ ê°œë°œ"
      - "ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"
    inputs:
      - "architecture_design.md"
      - "tech_stack_analysis.md"
    outputs:
      - "prototype/"
      - "demo_app/"
      - "performance_results.md"
      
  - stage: "Documentation & Presentation"
    agent: "gemini_cli"
    tasks:
      - "ì¢…í•© ë³´ê³ ì„œ ì‘ì„±"
      - "í”„ë ˆì  í…Œì´ì…˜ ìë£Œ ìƒì„±"
      - "ì‹œê°ì  ìë£Œ ì œì‘"
    inputs:
      - "feasibility_report.md"
      - "performance_results.md"
    outputs:
      - "final_report.md"
      - "presentation.pptx"
      - "infographics/"

automation_rules:
  - trigger: "stage_completed"
    condition: "all_tasks_done"
    action: "move_to_next_stage"
    
  - trigger: "task_failed"
    condition: "error_count > 2"
    action: "escalate_to_human"
    
  - trigger: "research_completed"
    condition: "final_stage_done"
    action: "create_github_release"
```

#### 2. ìë™í™”ëœ ë¬¸ì„œ ìƒì„±
```python
# documentation-generator.py
class DocumentationGenerator:
    def __init__(self):
        self.claude = ClaudeCodeAgent()
        self.gemini = GeminiCLIAgent()
        
    async def generate_project_docs(self, project_path):
        """í”„ë¡œì íŠ¸ ì „ì²´ ë¬¸ì„œ ìë™ ìƒì„±"""
        
        # 1. ì½”ë“œ ë¶„ì„
        code_analysis = await self.claude.executeTask({
            "title": "ì½”ë“œë² ì´ìŠ¤ ë¶„ì„",
            "description": f"í”„ë¡œì íŠ¸ {project_path}ì˜ ì „ì²´ êµ¬ì¡°ì™€ ê¸°ëŠ¥ì„ ë¶„ì„í•˜ì„¸ìš”",
            "context": {
                "project_path": project_path,
                "include_dependencies": True,
                "analyze_patterns": True
            }
        })
        
        # 2. API ë¬¸ì„œ ìƒì„±
        api_docs = await self.claude.executeTask({
            "title": "API ë¬¸ì„œ ìƒì„±",
            "description": "REST API ì—”ë“œí¬ì¸íŠ¸ ë¬¸ì„œë¥¼ ìë™ ìƒì„±í•˜ì„¸ìš”",
            "context": {
                "code_analysis": code_analysis,
                "format": "openapi_3.0",
                "include_examples": True
            }
        })
        
        # 3. ì‚¬ìš©ì ê°€ì´ë“œ ìƒì„±
        user_guide = await self.gemini.executeTask({
            "title": "ì‚¬ìš©ì ê°€ì´ë“œ ìƒì„±",
            "description": "ì´ˆë³´ìë„ ì´í•´í•  ìˆ˜ ìˆëŠ” ì‚¬ìš©ì ê°€ì´ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”",
            "context": {
                "api_docs": api_docs,
                "target_audience": "developers",
                "include_tutorials": True,
                "include_screenshots": True
            }
        })
        
        # 4. ë°°í¬ ê°€ì´ë“œ ìƒì„±
        deployment_guide = await self.claude.executeTask({
            "title": "ë°°í¬ ê°€ì´ë“œ ìƒì„±",
            "description": "ë‹¤ì–‘í•œ í™˜ê²½ì—ì„œì˜ ë°°í¬ ë°©ë²•ì„ ë¬¸ì„œí™”í•˜ì„¸ìš”",
            "context": {
                "deployment_targets": ["docker", "kubernetes", "aws", "vercel"],
                "include_troubleshooting": True
            }
        })
        
        # 5. ë¬¸ì„œ í†µí•© ë° ì •ë¦¬
        final_docs = await self.gemini.executeTask({
            "title": "ë¬¸ì„œ í†µí•©",
            "description": "ëª¨ë“  ë¬¸ì„œë¥¼ í†µí•©í•˜ê³  ì¼ê´€ì„± ìˆê²Œ ì •ë¦¬í•˜ì„¸ìš”",
            "context": {
                "documents": [api_docs, user_guide, deployment_guide],
                "format": "gitbook",
                "create_index": True,
                "add_navigation": True
            }
        })
        
        return final_docs

# ì‚¬ìš© ì˜ˆì œ
async def main():
    generator = DocumentationGenerator()
    docs = await generator.generate_project_docs("./my-awesome-project")
    
    # GitHubì— ë¬¸ì„œ ì»¤ë°‹
    subprocess.run([
        "git", "add", "docs/",
        "git", "commit", "-m", "ğŸ“š Auto-generated documentation",
        "git", "push"
    ])
    
    print("âœ… í”„ë¡œì íŠ¸ ë¬¸ì„œ ìë™ ìƒì„± ì™„ë£Œ!")

# ì‹¤í–‰
import asyncio
asyncio.run(main())
```

## ğŸ¯ ê³ ê¸‰ ê¸°ëŠ¥ ë° í†µí•©

### Slack í†µí•©

#### 1. Slack ë´‡ ì„¤ì •
```javascript
// .vibe-kanban/integrations/slack-bot.js
const { App } = require('@slack/bolt');

class SlackKanbanBot {
  constructor(config) {
    this.app = new App({
      token: process.env.SLACK_BOT_TOKEN,
      signingSecret: process.env.SLACK_SIGNING_SECRET,
      socketMode: true,
      appToken: process.env.SLACK_APP_TOKEN
    });
    
    this.setupCommands();
    this.setupEvents();
  }

  setupCommands() {
    // /kanban status ëª…ë ¹ì–´
    this.app.command('/kanban-status', async ({ ack, body, client }) => {
      await ack();
      
      const status = await this.getKanbanStatus();
      
      await client.chat.postMessage({
        channel: body.channel_id,
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: "ğŸ¯ *Kanban Board Status*"
            }
          },
          {
            type: "section",
            fields: [
              {
                type: "mrkdwn",
                text: `*Backlog:* ${status.backlog} tasks`
              },
              {
                type: "mrkdwn",
                text: `*In Progress:* ${status.in_progress} tasks`
              },
              {
                type: "mrkdwn",
                text: `*Review:* ${status.review} tasks`
              },
              {
                type: "mrkdwn",
                text: `*Done:* ${status.done} tasks`
              }
            ]
          },
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: `ğŸ¤– *Active AI Agents:* ${status.active_agents.join(', ')}`
            }
          },
          {
            type: "actions",
            elements: [
              {
                type: "button",
                text: {
                  type: "plain_text",
                  text: "View Board"
                },
                url: "http://localhost:3000",
                action_id: "view_board"
              }
            ]
          }
        ]
      });
    });

    // /kanban create ëª…ë ¹ì–´
    this.app.command('/kanban-create', async ({ ack, body, client }) => {
      await ack();
      
      // ëª¨ë‹¬ ì—´ê¸°
      await client.views.open({
        trigger_id: body.trigger_id,
        view: {
          type: "modal",
          callback_id: "create_task_modal",
          title: {
            type: "plain_text",
            text: "Create New Task"
          },
          submit: {
            type: "plain_text",
            text: "Create"
          },
          blocks: [
            {
              type: "input",
              block_id: "task_title",
              element: {
                type: "plain_text_input",
                action_id: "title",
                placeholder: {
                  type: "plain_text",
                  text: "Enter task title"
                }
              },
              label: {
                type: "plain_text",
                text: "Title"
              }
            },
            {
              type: "input",
              block_id: "task_description",
              element: {
                type: "plain_text_input",
                action_id: "description",
                multiline: true,
                placeholder: {
                  type: "plain_text",
                  text: "Enter task description"
                }
              },
              label: {
                type: "plain_text",
                text: "Description"
              }
            },
            {
              type: "input",
              block_id: "task_type",
              element: {
                type: "static_select",
                action_id: "type",
                options: [
                  {
                    text: {
                      type: "plain_text",
                      text: "Feature"
                    },
                    value: "feature"
                  },
                  {
                    text: {
                      type: "plain_text",
                      text: "Bug Fix"
                    },
                    value: "bug_fix"
                  },
                  {
                    text: {
                      type: "plain_text",
                      text: "Documentation"
                    },
                    value: "documentation"
                  }
                ]
              },
              label: {
                type: "plain_text",
                text: "Task Type"
              }
            }
          ]
        }
      });
    });
  }

  setupEvents() {
    // íƒœìŠ¤í¬ ìƒì„± ëª¨ë‹¬ ì œì¶œ
    this.app.view('create_task_modal', async ({ ack, body, view, client }) => {
      await ack();
      
      const values = view.state.values;
      const task = {
        title: values.task_title.title.value,
        description: values.task_description.description.value,
        type: values.task_type.type.selected_option.value,
        created_by: body.user.id,
        board: 'Backlog'
      };
      
      // Kanban APIë¡œ íƒœìŠ¤í¬ ìƒì„±
      const response = await fetch('http://localhost:3000/api/tasks', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(task)
      });
      
      if (response.ok) {
        const createdTask = await response.json();
        
        // ì±„ë„ì— ì•Œë¦¼ ì „ì†¡
        await client.chat.postMessage({
          channel: body.user.id,
          text: `âœ… Task created: *${task.title}*\nView it at: http://localhost:3000/tasks/${createdTask.id}`
        });
      }
    });
  }

  async getKanbanStatus() {
    const response = await fetch('http://localhost:3000/api/status');
    return response.json();
  }

  async start() {
    await this.app.start();
    console.log('âš¡ï¸ Slack Kanban Bot is running!');
  }
}

module.exports = SlackKanbanBot;
```

### ë©”íŠ¸ë¦­ ë° ë¶„ì„

#### 1. ëŒ€ì‹œë³´ë“œ ì„¤ì •
```python
# analytics-dashboard.py
import streamlit as st
import pandas as pd
import plotly.express as px
import requests
from datetime import datetime, timedelta

class KanbanAnalytics:
    def __init__(self):
        self.api_base = "http://localhost:3000/api"
        
    def get_task_data(self, days=30):
        """ìµœê·¼ Nì¼ê°„ì˜ íƒœìŠ¤í¬ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°"""
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        response = requests.get(
            f"{self.api_base}/tasks",
            params={
                "start_date": start_date.isoformat(),
                "end_date": end_date.isoformat()
            }
        )
        
        return pd.DataFrame(response.json())
    
    def get_agent_performance(self, days=30):
        """AI ì—ì´ì „íŠ¸ ì„±ëŠ¥ ë°ì´í„°"""
        response = requests.get(
            f"{self.api_base}/agents/performance",
            params={"days": days}
        )
        
        return pd.DataFrame(response.json())
    
    def render_dashboard(self):
        st.set_page_config(
            page_title="Vibe Kanban Analytics",
            page_icon="ğŸ“Š",
            layout="wide"
        )
        
        st.title("ğŸ“Š Vibe Kanban Analytics Dashboard")
        
        # ì‚¬ì´ë“œë°” í•„í„°
        st.sidebar.header("Filters")
        days = st.sidebar.slider("Days to analyze", 7, 90, 30)
        
        # ë°ì´í„° ë¡œë“œ
        task_data = self.get_task_data(days)
        agent_data = self.get_agent_performance(days)
        
        if task_data.empty:
            st.warning("No data available for the selected period")
            return
        
        # ë©”íŠ¸ë¦­ ìš”ì•½
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            total_tasks = len(task_data)
            st.metric("Total Tasks", total_tasks)
        
        with col2:
            completed_tasks = len(task_data[task_data['status'] == 'Done'])
            completion_rate = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0
            st.metric("Completion Rate", f"{completion_rate:.1f}%")
        
        with col3:
            avg_time = task_data['completion_time_hours'].mean()
            st.metric("Avg Completion Time", f"{avg_time:.1f}h")
        
        with col4:
            active_agents = agent_data['agent_name'].nunique()
            st.metric("Active AI Agents", active_agents)
        
        # ì°¨íŠ¸ë“¤
        col1, col2 = st.columns(2)
        
        with col1:
            # íƒœìŠ¤í¬ íƒ€ì…ë³„ ë¶„í¬
            fig_type = px.pie(
                task_data.groupby('type').size().reset_index(name='count'),
                values='count',
                names='type',
                title="Tasks by Type"
            )
            st.plotly_chart(fig_type, use_container_width=True)
        
        with col2:
            # ì™„ë£Œ ì‹œê°„ íŠ¸ë Œë“œ
            daily_completion = task_data.groupby(
                task_data['completed_date'].dt.date
            ).size().reset_index(name='completed_tasks')
            
            fig_trend = px.line(
                daily_completion,
                x='completed_date',
                y='completed_tasks',
                title="Daily Task Completion Trend"
            )
            st.plotly_chart(fig_trend, use_container_width=True)
        
        # AI ì—ì´ì „íŠ¸ ì„±ëŠ¥
        st.subheader("ğŸ¤– AI Agent Performance")
        
        agent_metrics = agent_data.groupby('agent_name').agg({
            'tasks_completed': 'sum',
            'avg_execution_time': 'mean',
            'success_rate': 'mean'
        }).round(2)
        
        st.dataframe(agent_metrics, use_container_width=True)
        
        # ì—ì´ì „íŠ¸ë³„ ì‘ì—… ì‹œê°„ ë¶„í¬
        fig_agent = px.box(
            agent_data,
            x='agent_name',
            y='execution_time_seconds',
            title="Agent Execution Time Distribution"
        )
        st.plotly_chart(fig_agent, use_container_width=True)
        
        # ìƒì„¸ íƒœìŠ¤í¬ ëª©ë¡
        st.subheader("ğŸ“‹ Recent Tasks")
        
        # í•„í„° ì˜µì…˜
        status_filter = st.selectbox(
            "Filter by status",
            options=['All'] + list(task_data['status'].unique())
        )
        
        filtered_data = task_data
        if status_filter != 'All':
            filtered_data = task_data[task_data['status'] == status_filter]
        
        st.dataframe(
            filtered_data[['title', 'type', 'status', 'assignee', 'created_date', 'completion_time_hours']],
            use_container_width=True
        )

# Streamlit ì•± ì‹¤í–‰
if __name__ == "__main__":
    analytics = KanbanAnalytics()
    analytics.render_dashboard()
```

#### 2. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ìŠ¤í¬ë¦½íŠ¸
```bash
#!/bin/bash
# performance-monitoring.sh

echo "ğŸ“Š Vibe Kanban ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘..."

# ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ í™•ì¸
echo "=== ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ==="
echo "CPU ì‚¬ìš©ë¥ : $(top -l 1 | grep "CPU usage" | awk '{print $3}' | sed 's/%//')"
echo "ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : $(vm_stat | grep "Pages active" | awk '{print $3}' | sed 's/\.//')"
echo "ë””ìŠ¤í¬ ì‚¬ìš©ë¥ : $(df -h . | tail -1 | awk '{print $5}')"

# Vibe Kanban API ìƒíƒœ í™•ì¸
echo -e "\n=== API ìƒíƒœ ==="
API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/health)
if [ "$API_STATUS" = "200" ]; then
    echo "âœ… API ì„œë²„ ì •ìƒ"
else
    echo "âŒ API ì„œë²„ ì˜¤ë¥˜ (HTTP $API_STATUS)"
fi

# í™œì„± AI ì—ì´ì „íŠ¸ í™•ì¸
echo -e "\n=== AI ì—ì´ì „íŠ¸ ìƒíƒœ ==="
AGENTS_STATUS=$(curl -s http://localhost:3000/api/agents/status)
echo "$AGENTS_STATUS" | jq -r '.agents[] | "\(.name): \(.status) (Tasks: \(.active_tasks))"'

# ìµœê·¼ ì—ëŸ¬ ë¡œê·¸ í™•ì¸
echo -e "\n=== ìµœê·¼ ì—ëŸ¬ ë¡œê·¸ ==="
if [ -f ".vibe-kanban/logs/error.log" ]; then
    tail -5 .vibe-kanban/logs/error.log
else
    echo "ì—ëŸ¬ ë¡œê·¸ ì—†ìŒ"
fi

# ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
echo -e "\n=== ì„±ëŠ¥ ë©”íŠ¸ë¦­ ==="
METRICS=$(curl -s http://localhost:3000/api/metrics)
echo "$METRICS" | jq -r '
"í‰ê·  ì‘ë‹µì‹œê°„: \(.avg_response_time_ms)ms",
"ì²˜ë¦¬ëœ íƒœìŠ¤í¬: \(.tasks_processed_today)",
"ì„±ê³µë¥ : \(.success_rate)%",
"í™œì„± ì—°ê²°: \(.active_connections)"
'

# ìë™í™”ëœ ì•Œë¦¼ (ì„ íƒì‚¬í•­)
if [ "$API_STATUS" != "200" ]; then
    # Slack ì•Œë¦¼ ì „ì†¡
    curl -X POST -H 'Content-type: application/json' \
        --data '{"text":"ğŸš¨ Vibe Kanban API ì„œë²„ ë‹¤ìš´!"}' \
        "$SLACK_WEBHOOK_URL"
fi

echo -e "\nâœ… ëª¨ë‹ˆí„°ë§ ì™„ë£Œ"
```

## zshrc ë³„ì¹­ ì„¤ì •

```bash
# ~/.zshrcì— ì¶”ê°€í•  Vibe Kanban ê´€ë ¨ ë³„ì¹­ë“¤

# Vibe Kanban ê´€ë ¨ ë””ë ‰í† ë¦¬
export VIBE_KANBAN_HOME="$HOME/.vibe-kanban"
export VIBE_PROJECTS_DIR="$HOME/vibe-projects"

# ê¸°ë³¸ ë³„ì¹­
alias vkanban="npx vibe-kanban"
alias vk="npx vibe-kanban"
alias vk-init="npx vibe-kanban init"
alias vk-start="npm run kanban"
alias vk-dev="npm run kanban:dev"

# í”„ë¡œì íŠ¸ ê´€ë¦¬
alias vk-new="mkdir -p $VIBE_PROJECTS_DIR && cd $VIBE_PROJECTS_DIR"
alias vk-list="ls -la $VIBE_PROJECTS_DIR"
alias vk-goto="cd $VIBE_PROJECTS_DIR"

# ì„¤ì • ê´€ë¦¬
alias vk-config="code $VIBE_KANBAN_HOME/config.json"
alias vk-agents="code $VIBE_KANBAN_HOME/agents/"
alias vk-workflows="code $VIBE_KANBAN_HOME/workflows/"

# API ë° ìƒíƒœ í™•ì¸
alias vk-status="curl -s http://localhost:3000/api/health | jq ."
alias vk-agents-status="curl -s http://localhost:3000/api/agents/status | jq ."
alias vk-metrics="curl -s http://localhost:3000/api/metrics | jq ."

# ë¡œê·¸ í™•ì¸
alias vk-logs="tail -f $VIBE_KANBAN_HOME/logs/app.log"
alias vk-errors="tail -f $VIBE_KANBAN_HOME/logs/error.log"

# GitHub í†µí•©
alias vk-gh-setup="gh auth login && gh api user"
alias vk-webhook="ngrok http 3000" # ë¡œì»¬ ì›¹í›… í…ŒìŠ¤íŠ¸ìš©

# ê°œë°œ ë„êµ¬
alias vk-test="npm run test"
alias vk-lint="npm run lint"
alias vk-build="npm run build"

# ë°±ì—… ë° ë³µì›
function vk-backup() {
    local backup_name="vibe-kanban-backup-$(date +%Y%m%d-%H%M%S)"
    tar -czf "$backup_name.tar.gz" "$VIBE_KANBAN_HOME" 
    echo "âœ… ë°±ì—… ì™„ë£Œ: $backup_name.tar.gz"
}

function vk-restore() {
    if [ -z "$1" ]; then
        echo "ì‚¬ìš©ë²•: vk-restore <backup-file.tar.gz>"
        return 1
    fi
    tar -xzf "$1" -C "$HOME"
    echo "âœ… ë³µì› ì™„ë£Œ: $1"
}

# ë¹ ë¥¸ íƒœìŠ¤í¬ ìƒì„±
function vk-task() {
    if [ -z "$1" ]; then
        echo "ì‚¬ìš©ë²•: vk-task 'Task Title' ['Description']"
        return 1
    fi
    
    local title="$1"
    local description="${2:-Auto-created task}"
    
    curl -X POST http://localhost:3000/api/tasks \
        -H "Content-Type: application/json" \
        -d "{
            \"title\": \"$title\",
            \"description\": \"$description\",
            \"type\": \"Feature\",
            \"board\": \"Backlog\"
        }" | jq .
}

# í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
function vk-init-project() {
    local project_name="$1"
    if [ -z "$project_name" ]; then
        echo "ì‚¬ìš©ë²•: vk-init-project <project-name>"
        return 1
    fi
    
    mkdir -p "$VIBE_PROJECTS_DIR/$project_name"
    cd "$VIBE_PROJECTS_DIR/$project_name"
    
    npm init -y
    npm install --save-dev vibe-kanban
    npx vibe-kanban init
    
    echo "âœ… í”„ë¡œì íŠ¸ '$project_name' ì´ˆê¸°í™” ì™„ë£Œ"
    echo "ğŸ“ ê²½ë¡œ: $VIBE_PROJECTS_DIR/$project_name"
}

# ì—ì´ì „íŠ¸ í…ŒìŠ¤íŠ¸
function vk-test-agent() {
    local agent_name="$1"
    if [ -z "$agent_name" ]; then
        echo "ì‚¬ìš© ê°€ëŠ¥í•œ ì—ì´ì „íŠ¸: claude_code, gemini_cli, cursor"
        return 1
    fi
    
    curl -X POST "http://localhost:3000/api/agents/$agent_name/test" \
        -H "Content-Type: application/json" \
        -d '{"test_task": "Hello, World!"}' | jq .
}

# ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
function vk-monitor() {
    echo "ğŸ“Š Vibe Kanban ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§..."
    while true; do
        clear
        echo "=== $(date) ==="
        vk-status
        echo ""
        vk-agents-status
        echo ""
        echo "ë‹¤ìŒ ì—…ë°ì´íŠ¸ê¹Œì§€ 5ì´ˆ..."
        sleep 5
    done
}

# ë„ì›€ë§
function vk-help() {
    echo "ğŸš€ Vibe Kanban ë³„ì¹­ ë„ì›€ë§"
    echo ""
    echo "ê¸°ë³¸ ì‚¬ìš©:"
    echo "  vkanban        - Vibe Kanban ì‹¤í–‰"
    echo "  vk-init        - ìƒˆ í”„ë¡œì íŠ¸ ì´ˆê¸°í™”"
    echo "  vk-start       - ê°œë°œ ì„œë²„ ì‹œì‘"
    echo ""
    echo "í”„ë¡œì íŠ¸ ê´€ë¦¬:"
    echo "  vk-init-project <name>  - ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±"
    echo "  vk-list        - í”„ë¡œì íŠ¸ ëª©ë¡"
    echo "  vk-goto        - í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¡œ ì´ë™"
    echo ""
    echo "ìƒíƒœ í™•ì¸:"
    echo "  vk-status      - API ì„œë²„ ìƒíƒœ"
    echo "  vk-agents-status - AI ì—ì´ì „íŠ¸ ìƒíƒœ"
    echo "  vk-monitor     - ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§"
    echo ""
    echo "ê°œë°œ ë„êµ¬:"
    echo "  vk-task 'title' - ë¹ ë¥¸ íƒœìŠ¤í¬ ìƒì„±"
    echo "  vk-test-agent <name> - ì—ì´ì „íŠ¸ í…ŒìŠ¤íŠ¸"
    echo "  vk-backup      - ì„¤ì • ë°±ì—…"
    echo ""
    echo "ì„¤ì •:"
    echo "  vk-config      - ì„¤ì • íŒŒì¼ í¸ì§‘"
    echo "  vk-agents      - ì—ì´ì „íŠ¸ ì„¤ì • í¸ì§‘"
    echo "  vk-workflows   - ì›Œí¬í”Œë¡œìš° í¸ì§‘"
}
```

## ê°œë°œí™˜ê²½ ì •ë³´

```bash
# í…ŒìŠ¤íŠ¸ í™˜ê²½ ì •ë³´
echo "=== Vibe Kanban ê°œë°œí™˜ê²½ ì •ë³´ ==="
echo "ë‚ ì§œ: $(date)"
echo "OS: $(uname -a)"
echo "Node.js: $(node --version 2>/dev/null || echo 'Node.js not installed')"
echo "npm: $(npm --version 2>/dev/null || echo 'npm not installed')"
echo "Git: $(git --version 2>/dev/null || echo 'Git not installed')"
echo "GitHub CLI: $(gh --version 2>/dev/null | head -1 || echo 'GitHub CLI not installed')"
echo "Python: $(python --version 2>&1 || echo 'Python not installed')"
echo "ì‚¬ìš© ê°€ëŠ¥ ë©”ëª¨ë¦¬: $(free -h 2>/dev/null | grep Mem || vm_stat | head -5)"
echo "ë””ìŠ¤í¬ ê³µê°„: $(df -h . | tail -1)"
```

### ê²€ì¦ëœ í™˜ê²½

ì´ ê°€ì´ë“œëŠ” ë‹¤ìŒ í™˜ê²½ì—ì„œ í…ŒìŠ¤íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤:

```
- macOS Sonoma (Apple M4 Pro, 48GB RAM)
- Ubuntu 22.04 LTS
- Node.js 20.0+ (LTS)
- npm 10.0+
- GitHub CLI 2.40+
- Python 3.10+
```

## ê²°ë¡ 

Vibe Kanbanì€ Apache-2.0 ë¼ì´ì„ ìŠ¤ í•˜ì—ì„œ **ì™„ì „íˆ ììœ ë¡œìš´ ìƒì—…ì  ì‚¬ìš©ì´ ê°€ëŠ¥**í•œ í˜ì‹ ì ì¸ AI ì—ì´ì „íŠ¸ ê´€ë¦¬ ë„êµ¬ì…ë‹ˆë‹¤. ê¸°ì¡´ GitHub í”„ë¡œì íŠ¸ì™€ì˜ ì™„ë²½í•œ í†µí•©ì„ í†µí•´ ë‹¤ìŒê³¼ ê°™ì€ ê°•ë ¥í•œ ê¸°ëŠ¥ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤:

### ğŸ¯ ì£¼ìš” ì¥ì 

1. **AI ì—ì´ì „íŠ¸ í†µí•© ê´€ë¦¬**: Claude Code, Gemini CLI ë“± ë‹¤ì–‘í•œ AI ë„êµ¬ë“¤ì„ í•˜ë‚˜ì˜ í”Œë«í¼ì—ì„œ ê´€ë¦¬
2. **ì‹œê°ì  ì›Œí¬í”Œë¡œìš°**: ì¹¸ë°˜ ë³´ë“œë¥¼ í†µí•œ ì§ê´€ì ì¸ ì‘ì—… íë¦„ ê´€ë¦¬
3. **GitHub ì™„ë²½ ì—°ë™**: ì´ìŠˆ, PR, ì»¤ë°‹ê³¼ ìë™ ë™ê¸°í™”
4. **ìë™í™”ëœ ì›Œí¬í”Œë¡œìš°**: AI ì—ì´ì „íŠ¸ ê°„ í˜‘ì—…ì„ í†µí•œ ìë™í™”ëœ ê°œë°œ í”„ë¡œì„¸ìŠ¤
5. **í™•ì¥ ê°€ëŠ¥í•œ ì•„í‚¤í…ì²˜**: í”ŒëŸ¬ê·¸ì¸ê³¼ í†µí•©ì„ í†µí•œ ë¬´í•œí•œ í™•ì¥ì„±

### ğŸš€ ê¶Œì¥ ë„ì… ì „ëµ

1. **ê°œì¸ í”„ë¡œì íŠ¸ë¶€í„° ì‹œì‘**: ì†Œê·œëª¨ í”„ë¡œì íŠ¸ì—ì„œ ì›Œí¬í”Œë¡œìš° ê²€ì¦
2. **íŒ€ ë‹¨ìœ„ í™•ì¥**: ì„±ê³µì ì¸ ê°œì¸ ì‚¬ìš© í›„ íŒ€ ì°¨ì›ìœ¼ë¡œ í™•ëŒ€
3. **ê¸°ì—… ì „ì‚¬ ë„ì…**: ê²€ì¦ëœ ì›Œí¬í”Œë¡œìš°ë¥¼ ì „ì‚¬ í‘œì¤€ìœ¼ë¡œ í™•ì‚°
4. **ì»¤ìŠ¤í„°ë§ˆì´ì§•**: ì¡°ì§ì˜ íŠ¹ì„±ì— ë§ëŠ” ì—ì´ì „íŠ¸ì™€ ì›Œí¬í”Œë¡œìš° ê°œë°œ

### ğŸ’¡ í™œìš© ì‹œë‚˜ë¦¬ì˜¤

- **ê°œë°œíŒ€**: ì½”ë“œ ë¦¬ë·°, ë²„ê·¸ ìˆ˜ì •, ê¸°ëŠ¥ ê°œë°œ ìë™í™”
- **ì—°êµ¬íŒ€**: ë¬¸ì„œ ìƒì„±, ë°ì´í„° ë¶„ì„, ë¦¬í¬íŠ¸ ì‘ì„± ìë™í™”
- **ìŠ¤íƒ€íŠ¸ì—…**: ì œí•œëœ ì¸ë ¥ìœ¼ë¡œ ìµœëŒ€ íš¨ìœ¨ì„± ë‹¬ì„±
- **ëŒ€ê¸°ì—…**: ë³µì¡í•œ í”„ë¡œì íŠ¸ì˜ ì²´ê³„ì  ê´€ë¦¬

Vibe Kanbanì„ í†µí•´ AI ì—ì´ì „íŠ¸ë“¤ì´ ë‹¨ìˆœí•œ ë„êµ¬ê°€ ì•„ë‹Œ **ì§„ì •í•œ íŒ€ ë©¤ë²„**ë¡œ ê¸°ëŠ¥í•  ìˆ˜ ìˆìœ¼ë©°, ì¸ê°„ ê°œë°œìë“¤ì€ ë”ìš± ì°½ì˜ì ì´ê³  ì „ëµì ì¸ ì—…ë¬´ì— ì§‘ì¤‘í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

### ê´€ë ¨ ë§í¬

- [Vibe Kanban GitHub](https://github.com/BloopAI/vibe-kanban)
- [Apache-2.0 ë¼ì´ì„ ìŠ¤](https://www.apache.org/licenses/LICENSE-2.0)
- [Claude Code ê°€ì´ë“œ](https://docs.anthropic.com/claude/docs)
- [Gemini CLI ë¬¸ì„œ](https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini)
- [GitHub API ë¬¸ì„œ](https://docs.github.com/en/rest) 