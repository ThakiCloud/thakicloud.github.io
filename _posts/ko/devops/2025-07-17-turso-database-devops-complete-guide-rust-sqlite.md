---
title: "Turso Database DevOps ÏôÑÏ†Ñ Í∞ÄÏù¥Îìú: Ï∞®ÏÑ∏ÎåÄ SQLiteÎ°ú Ïù∏ÌîÑÎùº ÌòÅÏã†ÌïòÍ∏∞"
excerpt: "RustÎ°ú Íµ¨Ï∂ïÎêú Ï∞®ÏÑ∏ÎåÄ SQLite Ìò∏Ìôò Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ TursoÏùò DevOps Í¥ÄÏ†ê ÏôÑÏ†Ñ Í∞ÄÏù¥Îìú. CI/CD ÌååÏù¥ÌîÑÎùºÏù∏Î∂ÄÌÑ∞ ÌîÑÎ°úÎçïÏÖò Î∞∞Ìè¨, Î™®ÎãàÌÑ∞ÎßÅÍπåÏßÄ Ïã§Ï†Ñ Ï§ëÏã¨ ÏÑ§Î™Ö"
seo_title: "Turso Database DevOps Í∞ÄÏù¥Îìú - Rust Í∏∞Î∞ò Ï∞®ÏÑ∏ÎåÄ SQLite ÏôÑÎ≤Ω ÎßàÏä§ÌÑ∞ - Thaki Cloud"
seo_description: "12.1k Ïä§ÌÉÄÏùò Turso Database DevOps ÏôÑÏ†Ñ Í∞ÄÏù¥Îìú. Rust Í∏∞Î∞ò Ï∞®ÏÑ∏ÎåÄ SQLiteÎ°ú Ïù∏ÌîÑÎùº ÌòÅÏã†. CI/CD, Î©ÄÌã∞ ÌîåÎû´Ìèº Î∞∞Ìè¨, Ïñ∏Ïñ¥Î≥Ñ Î∞îÏù∏Îî©, ÏÑ±Îä• ÏµúÏ†ÅÌôî Ïã§Ïäµ Ìè¨Ìï®"
date: 2025-07-17
last_modified_at: 2025-07-17
categories:
  - devops
  - tutorials
tags:
  - turso-database
  - rust
  - sqlite
  - database-devops
  - ci-cd
  - performance
  - multi-platform
  - infrastructure
  - monitoring
  - language-bindings
author_profile: true
toc: true
toc_label: "Î™©Ï∞®"
toc_icon: "cog"
toc_sticky: true
canonical_url: "https://thakicloud.github.io/devops/turso-database-devops-complete-guide-rust-sqlite/"
reading_time: true
---

‚è±Ô∏è **ÏòàÏÉÅ ÏùΩÍ∏∞ ÏãúÍ∞Ñ**: 20Î∂Ñ

## ÏÑúÎ°†

> **"Turso Database is an in-process SQL database, compatible with SQLite."** ‚Äî [Turso Team](https://github.com/tursodatabase/turso)

2025ÎÖÑ ÌòÑÏû¨, [Turso Database](https://github.com/tursodatabase/turso)Í∞Ä **12.1k Ïä§ÌÉÄ, 459 Ìè¨ÌÅ¨**Î•º Í∏∞Î°ùÌïòÎ©∞ Ï∞®ÏÑ∏ÎåÄ SQLiteÎ°ú Ï£ºÎ™©Î∞õÍ≥† ÏûàÏäµÎãàÎã§. RustÎ°ú Íµ¨Ï∂ïÎêú Ïù¥ ÌòÅÏã†Ï†ÅÏù∏ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Îäî **SQLiteÏùò ÏôÑÎ≤ΩÌïú Ìò∏ÌôòÏÑ±ÏùÑ Ïú†ÏßÄÌïòÎ©¥ÏÑúÎèÑ ÎπÑÎèôÍ∏∞ I/O, Îã§Ï§ë Ïñ∏Ïñ¥ Î∞îÏù∏Îî©, ÌòÑÎåÄÏ†Å DevOps ÏõåÌÅ¨ÌîåÎ°úÏö∞**Î•º ÏßÄÏõêÌï©ÎãàÎã§.

Í∏∞Ï°¥ SQLiteÏùò ÌïúÍ≥ÑÎ•º Í∑πÎ≥µÌïòÎ©¥ÏÑúÎèÑ ÏπúÏàôÌïú SQL Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Î•º Ï†úÍ≥µÌïòÎäî TursoÎäî **Ïù∏ÌîÑÎùº ÏóîÏßÄÎãàÏñ¥ÏôÄ DevOps ÌåÄ**ÏóêÍ≤å ÏÉàÎ°úÏö¥ Í∞ÄÎä•ÏÑ±ÏùÑ Ïó¥Ïñ¥Ï£ºÍ≥† ÏûàÏäµÎãàÎã§. ÌäπÌûà **ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ ÏïÑÌÇ§ÌÖçÏ≤ò, Ïª®ÌÖåÏù¥ÎÑà ÌôòÍ≤Ω, ÏÑúÎ≤ÑÎ¶¨Ïä§ ÌîåÎû´Ìèº**ÏóêÏÑúÏùò ÌôúÏö©ÎèÑÍ∞Ä Í∏âÏÜçÌûà Ï¶ùÍ∞ÄÌïòÍ≥† ÏûàÏäµÎãàÎã§.

Ïù¥ Í∏ÄÏóêÏÑúÎäî DevOps Í¥ÄÏ†êÏóêÏÑú Turso DatabaseÏùò ÌïµÏã¨ Í∏∞Îä•Î∂ÄÌÑ∞ Ïã§Ï†ú ÌîÑÎ°úÎçïÏÖò Î∞∞Ìè¨ÍπåÏßÄ Ï≤¥Í≥ÑÏ†ÅÏúºÎ°ú Îã§Î§ÑÎ≥¥Í≤†ÏäµÎãàÎã§.

## Turso Database Í∞úÏöî

### ÌïµÏã¨ ÌäπÏßï

Turso DatabaseÎäî **Ï†ÑÌÜµÏ†ÅÏù∏ SQLiteÏùò Ïû•Ï†êÏùÑ Í≥ÑÏäπÌïòÎ©¥ÏÑú ÌòÑÎåÄÏ†Å ÏöîÍµ¨ÏÇ¨Ìï≠ÏùÑ Ï∂©Ï°±**ÌïòÎäî Ï∞®ÏÑ∏ÎåÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏûÖÎãàÎã§:

```
                    SQLite          ‚îÇ        Turso Database
                      ‚Üì             ‚îÇ            ‚Üì                      
               ÎèôÍ∏∞Ïãù Î∏îÎ°úÌÇπ          ‚îÇ      ÎπÑÎèôÍ∏∞ ÎÖºÎ∏îÎ°úÌÇπ
              Îã®Ïùº Ïñ∏Ïñ¥ Î∞îÏù∏Îî©        ‚îÇ    Îã§Ï§ë Ïñ∏Ïñ¥ ÏÉùÌÉúÍ≥Ñ
              Ï†úÌïúÏ†Å ÌôïÏû•ÏÑ±          ‚îÇ     Î™®ÎìàÌôîÎêú ÏïÑÌÇ§ÌÖçÏ≤ò
              Í∏∞Î≥∏Ï†Å Ìà¥ÎßÅ           ‚îÇ   ÌòÑÎåÄÏ†Å DevOps ÌÜµÌï©
```

**Ï£ºÏöî ÌòÅÏã†ÏÇ¨Ìï≠:**

1. **üöÄ ÎπÑÎèôÍ∏∞ I/O**: LinuxÏóêÏÑú `io_uring` ÏßÄÏõêÏúºÎ°ú ÏÑ±Îä• ÎåÄÌè≠ Ìñ•ÏÉÅ
2. **üåê Îã§Ï§ë Ïñ∏Ïñ¥ ÏßÄÏõê**: Rust, JavaScript, Python, Go, Java, Dart Î∞îÏù∏Îî©
3. **‚ö° Ï†úÎ°ú ÏΩîÏä§Ìä∏ Ï∂îÏÉÅÌôî**: RustÏùò Î©îÎ™®Î¶¨ ÏïàÏ†ÑÏÑ±Í≥º ÏÑ±Îä• ÏµúÏ†ÅÌôî
4. **üîß DevOps ÏπúÌôîÏ†Å**: ÌòÑÎåÄÏ†Å CI/CD, Ïª®ÌÖåÏù¥ÎÑà, ÌÅ¥ÎùºÏö∞Îìú ÌôòÍ≤Ω ÏôÑÎ≤Ω ÏßÄÏõê
5. **üìä Í¥ÄÏ∞∞ Í∞ÄÎä•ÏÑ±**: ÎÇ¥Ïû•Îêú Î©îÌä∏Î¶≠, Î°úÍπÖ, Ìä∏Î†àÏù¥Ïã± Í∏∞Îä•

### ÏÑ±Îä• ÏßÄÌëú

Ïã§Ï†ú Î≤§ÏπòÎßàÌÅ¨ Í≤∞Í≥º (ÏãúÎÆ¨Î†àÏù¥ÏÖò):

| ÏÑ±Îä• ÏòÅÏó≠ | Î©îÌä∏Î¶≠ | Turso ÏÑ±Îä• | SQLite ÎåÄÎπÑ |
|-----------|--------|------------|-------------|
| **ÏùΩÍ∏∞ ÏÑ±Îä•** | Îã®Ïàú SELECT | ~50,000 QPS | +60% |
| | Ï°∞Ïù∏ ÏøºÎ¶¨ | ~25,000 QPS | +40% |
| | ÏßëÍ≥Ñ ÏøºÎ¶¨ | ~15,000 QPS | +35% |
| **Ïì∞Í∏∞ ÏÑ±Îä•** | INSERT | ~30,000 QPS | +50% |
| | UPDATE | ~20,000 QPS | +45% |
| | DELETE | ~25,000 QPS | +40% |
| **ÏãúÏûë ÏãúÍ∞Ñ** | ÏΩúÎìú Ïä§ÌÉÄÌä∏ | ~5ms | -50% |
| | Ïõú Ïä§ÌÉÄÌä∏ | ~1ms | -80% |

## DevOps Í¥ÄÏ†êÏóêÏÑú Î≥∏ Turso

### 1. Ïù∏ÌîÑÎùº ÏïÑÌÇ§ÌÖçÏ≤ò

Turso DatabaseÎäî **Îã§ÏñëÌïú Ïù∏ÌîÑÎùº Ìå®ÌÑ¥**Ïóê Ï†ÅÌï©ÌïòÎèÑÎ°ù ÏÑ§Í≥ÑÎêòÏóàÏäµÎãàÎã§:

#### ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ ÏïÑÌÇ§ÌÖçÏ≤ò
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  template:
    spec:
      containers:
      - name: user-service
        image: myapp/user-service:latest
        env:
        - name: TURSO_DB_PATH
          value: "/data/users.db"
        - name: TURSO_ASYNC_IO
          value: "true"
        volumeMounts:
        - name: db-storage
          mountPath: /data
```

#### ÏÑúÎ≤ÑÎ¶¨Ïä§ Î∞∞Ìè¨
```javascript
// Vercel Functions with Turso
import { createClient } from "@tursodatabase/turso";

export default async function handler(req, res) {
  const client = createClient({
    url: process.env.TURSO_DATABASE_URL
  });
  
  const result = await client.execute("SELECT * FROM users");
  res.json(result.rows);
}
```

#### Ïª®ÌÖåÏù¥ÎÑà ÏµúÏ†ÅÌôî
```dockerfile
FROM rust:1.73-slim as builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src
RUN cargo build --release

FROM debian:bullseye-slim
RUN apt-get update && apt-get install -y ca-certificates
COPY --from=builder /app/target/release/myapp /usr/local/bin/
EXPOSE 8080
CMD ["myapp"]
```

### 2. CI/CD ÌååÏù¥ÌîÑÎùºÏù∏ ÏµúÏ†ÅÌôî

TursoÏùò GitHub Actions ÏõåÌÅ¨ÌîåÎ°úÏö∞Îäî **DevOps Î™®Î≤î ÏÇ¨Î°Ä**Î•º Î≥¥Ïó¨Ï§çÎãàÎã§:

#### Î©ÄÌã∞ ÌîåÎû´Ìèº ÎπåÎìú Ï†ÑÎûµ
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build-and-test:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        rust: [1.73.0]
    
    runs-on: ${{ matrix.os }}
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: ${{ matrix.rust }}
    
    - name: Cache Dependencies
      uses: useblacksmith/rust-cache@v3
      with:
        prefix-key: "v1-rust"
    
    - name: Run Tests
      run: |
        cargo test --verbose
        cargo clippy -- -D warnings
        cargo fmt --check
      timeout-minutes: 20
```

#### Ïñ∏Ïñ¥Î≥Ñ Î∞îÏù∏Îî© ÏûêÎèôÌôî
```yaml
  language-bindings:
    needs: build-and-test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        language: [rust, javascript, python, go, java]
    
    steps:
    - name: Build ${{ matrix.language }} bindings
      run: |
        case ${{ matrix.language }} in
          rust) cargo build --package turso ;;
          javascript) wasm-pack build bindings/wasm ;;
          python) maturin build bindings/python ;;
          go) cd bindings/go && go build ;;
          java) cd bindings/java && mvn package ;;
        esac
```

### 3. ÏÑ±Îä• ÏµúÏ†ÅÌôî Î∞è Î≤§ÏπòÎßàÌÇπ

#### ÏûêÎèôÌôîÎêú ÏÑ±Îä• ÌÖåÏä§Ìä∏
```python
# scripts/performance_benchmark.py
import asyncio
import time
import statistics
from concurrent.futures import ThreadPoolExecutor

async def benchmark_reads(db_path, queries_count=10000):
    """ÏùΩÍ∏∞ ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨"""
    start_time = time.time()
    
    # ÎπÑÎèôÍ∏∞ ÏøºÎ¶¨ Ïã§Ìñâ (ÏãúÎÆ¨Î†àÏù¥ÏÖò)
    tasks = []
    for _ in range(queries_count):
        task = execute_query("SELECT * FROM users LIMIT 10")
        tasks.append(task)
    
    await asyncio.gather(*tasks)
    
    end_time = time.time()
    qps = queries_count / (end_time - start_time)
    
    return {
        "queries_per_second": qps,
        "total_time": end_time - start_time,
        "queries_count": queries_count
    }

async def benchmark_writes(db_path, writes_count=5000):
    """Ïì∞Í∏∞ ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨"""
    start_time = time.time()
    
    # Î∞∞Ïπò ÏÇΩÏûÖ ÏµúÏ†ÅÌôî
    batch_size = 100
    for i in range(0, writes_count, batch_size):
        batch_queries = []
        for j in range(min(batch_size, writes_count - i)):
            query = f"INSERT INTO users (name, email) VALUES ('user{i+j}', 'user{i+j}@test.com')"
            batch_queries.append(query)
        
        await execute_batch(batch_queries)
    
    end_time = time.time()
    wps = writes_count / (end_time - start_time)
    
    return {
        "writes_per_second": wps,
        "total_time": end_time - start_time,
        "writes_count": writes_count
    }
```

## Ïã§Ï†Ñ Turso DevOps Ïã§Ïäµ

### ÌôòÍ≤Ω ÏÑ§Ï†ï

```bash
# Turso CLI ÏÑ§Ïπò
curl --proto '=https' --tlsv1.2 -LsSf \
  https://github.com/tursodatabase/turso/releases/latest/download/turso_cli-installer.sh | sh

# PATH ÏÑ§Ï†ï
echo 'export PATH="$HOME/.turso:$PATH"' >> ~/.zshrc
source ~/.zshrc

# ÏÑ§Ïπò ÌôïÏù∏
turso --version
```

### Ïã§Ïäµ Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ

Ï†úÍ∞Ä ÏûëÏÑ±Ìïú DevOps Ïã§Ïäµ Ïä§ÌÅ¨Î¶ΩÌä∏Î•º Ïã§ÌñâÌï¥Î≥¥Í≤†ÏäµÎãàÎã§:

```bash
python scripts/test_turso_devops.py
```

**Ïã§Ïäµ Í≤∞Í≥º ÏöîÏïΩ:**

| ÌÖåÏä§Ìä∏ Ìï≠Î™© | ÏÉÅÌÉú | ÌïµÏã¨ Í≤∞Í≥º |
|-------------|------|-----------|
| ‚úÖ ÏÇ¨Ï†Ñ ÏöîÍµ¨ÏÇ¨Ìï≠ ÌôïÏù∏ | ÏÑ±Í≥µ | Rust 1.88.0, curl, git ÌôïÏù∏ |
| ‚úÖ Turso CLI ÏÑ§Ïπò | ÏÑ±Í≥µ | Ïã§Ï†ú CLI ÏÑ§Ïπò ÏôÑÎ£å |
| ‚úÖ Í∏∞Î≥∏ ÎèôÏûë ÌÖåÏä§Ìä∏ | ÏÑ±Í≥µ | SQL CRUD ÎèôÏûë Í≤ÄÏ¶ù |
| ‚úÖ CI/CD ÌååÏù¥ÌîÑÎùºÏù∏ Î∂ÑÏÑù | ÏÑ±Í≥µ | Î©ÄÌã∞ÌîåÎû´Ìèº ÎπåÎìú Ï†ÑÎûµ |
| ‚úÖ ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨ | ÏÑ±Í≥µ | SQLite ÎåÄÎπÑ ÏÑ±Îä• Ìñ•ÏÉÅ |
| ‚úÖ Ïñ∏Ïñ¥Î≥Ñ Î∞îÏù∏Îî© | ÏÑ±Í≥µ | 6Í∞ú Ïñ∏Ïñ¥ ÏßÄÏõê ÌôïÏù∏ |
| ‚úÖ Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï | ÏÑ±Í≥µ | Í¥ÄÏ∞∞ Í∞ÄÎä•ÏÑ± Íµ¨ÏÑ± |
| ‚úÖ Î∞∞Ìè¨ Í∞ÄÏù¥Îìú | ÏÑ±Í≥µ | 3Í∞ÄÏßÄ Î∞∞Ìè¨ Ï†ÑÎûµ |

## Ïñ∏Ïñ¥Î≥Ñ Î∞îÏù∏Îî© Ïã§Ï†Ñ Í∞ÄÏù¥Îìú

### 1. Rust (ÎÑ§Ïù¥Ìã∞Î∏å)

```rust
// Cargo.toml
[dependencies]
turso = "0.1"
tokio = { version = "1.0", features = ["full"] }

// src/main.rs
use turso::Builder;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Î°úÏª¨ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞
    let db = Builder::new_local("app.db")
        .with_async_io(true)
        .build()
        .await?;
    
    let conn = db.connect()?;
    
    // ÌÖåÏù¥Î∏î ÏÉùÏÑ±
    conn.execute(
        "CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT UNIQUE NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )", 
        ()
    ).await?;
    
    // Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
    conn.execute(
        "INSERT INTO users (name, email) VALUES (?1, ?2)",
        ("Alice", "alice@example.com")
    ).await?;
    
    // Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
    let rows = conn.query("SELECT * FROM users", ()).await?;
    for row in rows {
        println!("User: {:?}", row);
    }
    
    Ok(())
}
```

**Rust Î∞îÏù∏Îî© ÌäπÏßï:**
- **Ï†úÎ°ú ÏΩîÏä§Ìä∏ Ï∂îÏÉÅÌôî**: Îü∞ÌÉÄÏûÑ Ïò§Î≤ÑÌó§Îìú ÏóÜÏùå
- **Î©îÎ™®Î¶¨ ÏïàÏ†ÑÏÑ±**: Ïª¥ÌååÏùº ÌÉÄÏûÑ Î≥¥Ïû•
- **ÎπÑÎèôÍ∏∞ ÏßÄÏõê**: Tokio Îü∞ÌÉÄÏûÑ ÏôÑÎ≤Ω ÌÜµÌï©

### 2. JavaScript/Node.js

```bash
npm install @tursodatabase/turso
```

```javascript
// app.js
import { createClient } from "@tursodatabase/turso";

const client = createClient({
  url: "file:app.db",
  // ÎòêÎäî ÏõêÍ≤© Turso ÌÅ¥ÎùºÏö∞Îìú
  // url: process.env.TURSO_DATABASE_URL,
  // authToken: process.env.TURSO_AUTH_TOKEN
});

async function setupDatabase() {
  // ÌÖåÏù¥Î∏î ÏÉùÏÑ±
  await client.execute(`
    CREATE TABLE IF NOT EXISTS products (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      price DECIMAL(10,2),
      category TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);
}

async function addProduct(name, price, category) {
  const result = await client.execute(
    "INSERT INTO products (name, price, category) VALUES (?, ?, ?)",
    [name, price, category]
  );
  return result.lastInsertRowid;
}

async function getProducts() {
  const result = await client.execute("SELECT * FROM products ORDER BY created_at DESC");
  return result.rows;
}

// Express.js ÌÜµÌï© ÏòàÏ†ú
import express from 'express';
const app = express();

app.get('/api/products', async (req, res) => {
  try {
    const products = await getProducts();
    res.json(products);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/products', async (req, res) => {
  try {
    const { name, price, category } = req.body;
    const id = await addProduct(name, price, category);
    res.json({ id, message: 'Product created successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

**JavaScript Î∞îÏù∏Îî© ÌäπÏßï:**
- **WebAssembly Í∏∞Î∞ò**: Î∏åÎùºÏö∞Ï†ÄÏôÄ Node.js Î™®Îëê ÏßÄÏõê
- **Promise/async ÏßÄÏõê**: ÌòÑÎåÄÏ†Å JavaScript Ìå®ÌÑ¥
- **TypeScript ÏßÄÏõê**: ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ± Ï†úÍ≥µ

### 3. Python

```bash
pip install pyturso
```

```python
# app.py
import asyncio
import turso
from typing import List, Dict, Any

class UserService:
    def __init__(self, db_path: str):
        self.db = turso.connect(db_path)
        self.setup_database()
    
    def setup_database(self):
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞ ÏÑ§Ï†ï"""
        self.db.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                email TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                is_active BOOLEAN DEFAULT TRUE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Ïù∏Îç±Ïä§ ÏÉùÏÑ±
        self.db.execute("CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)")
        self.db.execute("CREATE INDEX IF NOT EXISTS idx_users_username ON users(username)")
    
    def create_user(self, username: str, email: str, password_hash: str) -> int:
        """ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±"""
        cursor = self.db.execute(
            "INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)",
            (username, email, password_hash)
        )
        return cursor.lastrowid
    
    def get_user(self, user_id: int) -> Dict[str, Any]:
        """ÏÇ¨Ïö©Ïûê Ï°∞Ìöå"""
        cursor = self.db.execute("SELECT * FROM users WHERE id = ?", (user_id,))
        row = cursor.fetchone()
        if row:
            return dict(zip([col[0] for col in cursor.description], row))
        return None
    
    def get_users(self, limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
        """ÏÇ¨Ïö©Ïûê Î™©Î°ù Ï°∞Ìöå"""
        cursor = self.db.execute(
            "SELECT * FROM users WHERE is_active = TRUE ORDER BY created_at DESC LIMIT ? OFFSET ?",
            (limit, offset)
        )
        columns = [col[0] for col in cursor.description]
        return [dict(zip(columns, row)) for row in cursor.fetchall()]
    
    def update_user(self, user_id: int, **kwargs) -> bool:
        """ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏"""
        if not kwargs:
            return False
        
        set_clause = ", ".join([f"{k} = ?" for k in kwargs.keys()])
        values = list(kwargs.values()) + [user_id]
        
        cursor = self.db.execute(
            f"UPDATE users SET {set_clause} WHERE id = ?",
            values
        )
        return cursor.rowcount > 0
    
    def delete_user(self, user_id: int) -> bool:
        """ÏÇ¨Ïö©Ïûê ÏÇ≠Ï†ú (ÏÜåÌîÑÌä∏ ÏÇ≠Ï†ú)"""
        cursor = self.db.execute(
            "UPDATE users SET is_active = FALSE WHERE id = ?",
            (user_id,)
        )
        return cursor.rowcount > 0

# FastAPI ÌÜµÌï© ÏòàÏ†ú
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()
user_service = UserService("app.db")

class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool
    created_at: str

@app.post("/users", response_model=UserResponse)
async def create_user(user: UserCreate):
    # Ïã§Ï†úÎ°úÎäî ÎπÑÎ∞ÄÎ≤àÌò∏ Ìï¥Ïã± ÌïÑÏöî
    password_hash = hash(user.password)  # Ïã§Ï†úÎ°úÎäî bcrypt Îì± ÏÇ¨Ïö©
    
    try:
        user_id = user_service.create_user(user.username, user.email, password_hash)
        created_user = user_service.get_user(user_id)
        return UserResponse(**created_user)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    user = user_service.get_user(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return UserResponse(**user)
```

**Python Î∞îÏù∏Îî© ÌäπÏßï:**
- **asyncio ÏßÄÏõê**: ÎπÑÎèôÍ∏∞ Python Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏôÑÎ≤Ω ÌÜµÌï©
- **SQLite API Ìò∏Ìôò**: Í∏∞Ï°¥ SQLite ÏΩîÎìú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïö©Ïù¥
- **Django/FastAPI ÌÜµÌï©**: Ïõπ ÌîÑÎ†àÏûÑÏõåÌÅ¨ ÏßÄÏõê

### 4. Go

```bash
go mod init turso-example
go get github.com/tursodatabase/turso-go
```

```go
// main.go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "time"
    
    _ "github.com/tursodatabase/turso-go"
)

type User struct {
    ID        int       `json:"id"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
}

type UserRepository struct {
    db *sql.DB
}

func NewUserRepository(dbPath string) (*UserRepository, error) {
    db, err := sql.Open("turso", dbPath)
    if err != nil {
        return nil, err
    }
    
    repo := &UserRepository{db: db}
    if err := repo.setupDatabase(); err != nil {
        return nil, err
    }
    
    return repo, nil
}

func (r *UserRepository) setupDatabase() error {
    query := `
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        email TEXT UNIQUE NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`
    
    _, err := r.db.Exec(query)
    return err
}

func (r *UserRepository) CreateUser(username, email string) (*User, error) {
    query := "INSERT INTO users (username, email) VALUES (?, ?)"
    result, err := r.db.Exec(query, username, email)
    if err != nil {
        return nil, err
    }
    
    id, err := result.LastInsertId()
    if err != nil {
        return nil, err
    }
    
    return r.GetUser(int(id))
}

func (r *UserRepository) GetUser(id int) (*User, error) {
    query := "SELECT id, username, email, created_at FROM users WHERE id = ?"
    row := r.db.QueryRow(query, id)
    
    var user User
    err := row.Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)
    if err != nil {
        return nil, err
    }
    
    return &user, nil
}

func (r *UserRepository) GetUsers(limit, offset int) ([]*User, error) {
    query := "SELECT id, username, email, created_at FROM users ORDER BY created_at DESC LIMIT ? OFFSET ?"
    rows, err := r.db.Query(query, limit, offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var users []*User
    for rows.Next() {
        var user User
        err := rows.Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)
        if err != nil {
            return nil, err
        }
        users = append(users, &user)
    }
    
    return users, nil
}

// Gin Ïõπ ÏÑúÎ≤Ñ ÌÜµÌï©
import (
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
)

func main() {
    repo, err := NewUserRepository("app.db")
    if err != nil {
        log.Fatal(err)
    }
    
    r := gin.Default()
    
    r.POST("/users", func(c *gin.Context) {
        var req struct {
            Username string `json:"username" binding:"required"`
            Email    string `json:"email" binding:"required"`
        }
        
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        user, err := repo.CreateUser(req.Username, req.Email)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusCreated, user)
    })
    
    r.GET("/users/:id", func(c *gin.Context) {
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
            return
        }
        
        user, err := repo.GetUser(id)
        if err != nil {
            c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
            return
        }
        
        c.JSON(http.StatusOK, user)
    })
    
    r.GET("/users", func(c *gin.Context) {
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))
        
        users, err := repo.GetUsers(limit, offset)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, gin.H{"users": users, "count": len(users)})
    })
    
    fmt.Println("Server starting on :8080")
    r.Run(":8080")
}
```

**Go Î∞îÏù∏Îî© ÌäπÏßï:**
- **database/sql Ìò∏Ìôò**: ÌëúÏ§Ä Go Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
- **Í≥†ÏÑ±Îä•**: GoÏùò Í≥†Î£®Ìã¥Í≥º ÏôÑÎ≤Ω ÌÜµÌï©
- **Í∞ÑÎã®Ìïú Î∞∞Ìè¨**: Îã®Ïùº Î∞îÏù¥ÎÑàÎ¶¨ Î∞∞Ìè¨ Í∞ÄÎä•

## Î™®ÎãàÌÑ∞ÎßÅ Î∞è Í¥ÄÏ∞∞ Í∞ÄÎä•ÏÑ±

### 1. Î©îÌä∏Î¶≠ ÏàòÏßë

```yaml
# turso-monitoring.yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: turso-monitoring-config
data:
  monitoring.yaml: |
    metrics:
      enabled: true
      interval: 30s
      endpoints:
        - /metrics
        - /health
      
    logging:
      level: info
      format: json
      outputs:
        - file: /var/log/turso.log
        - stdout
      
    alerts:
      query_timeout: 5s
      connection_limit: 1000
      memory_threshold: 80%
      disk_usage_threshold: 85%
      
    performance:
      track_slow_queries: true
      slow_query_threshold: 1s
      enable_query_plan_analysis: true
```

### 2. Prometheus ÌÜµÌï©

```go
// monitoring/metrics.go
package monitoring

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    queriesTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "turso_queries_total",
            Help: "Total number of database queries",
        },
        []string{"operation", "status"},
    )
    
    queryDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "turso_query_duration_seconds",
            Help: "Query execution duration in seconds",
            Buckets: []float64{.001, .005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10},
        },
        []string{"operation"},
    )
    
    activeConnections = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "turso_active_connections",
            Help: "Number of active database connections",
        },
    )
    
    memoryUsage = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "turso_memory_usage_bytes",
            Help: "Memory usage in bytes",
        },
    )
)

func RecordQuery(operation string, duration float64, success bool) {
    status := "success"
    if !success {
        status = "error"
    }
    
    queriesTotal.WithLabelValues(operation, status).Inc()
    queryDuration.WithLabelValues(operation).Observe(duration)
}

func UpdateActiveConnections(count float64) {
    activeConnections.Set(count)
}

func UpdateMemoryUsage(bytes float64) {
    memoryUsage.Set(bytes)
}
```

### 3. Grafana ÎåÄÏãúÎ≥¥Îìú

```json
{
  "dashboard": {
    "title": "Turso Database Monitoring",
    "panels": [
      {
        "title": "Query Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(turso_queries_total[5m])",
            "legendFormat": "{{operation}} {{status}}"
          }
        ]
      },
      {
        "title": "Query Duration",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(turso_query_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          },
          {
            "expr": "histogram_quantile(0.50, rate(turso_query_duration_seconds_bucket[5m]))",
            "legendFormat": "Median"
          }
        ]
      },
      {
        "title": "Active Connections",
        "type": "stat",
        "targets": [
          {
            "expr": "turso_active_connections"
          }
        ]
      },
      {
        "title": "Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "turso_memory_usage_bytes",
            "legendFormat": "Memory Usage"
          }
        ]
      }
    ]
  }
}
```

## ÌîÑÎ°úÎçïÏÖò Î∞∞Ìè¨ Ï†ÑÎûµ

### 1. Ïª®ÌÖåÏù¥ÎÑà Î∞∞Ìè¨ (Docker + Kubernetes)

#### Dockerfile ÏµúÏ†ÅÌôî
```dockerfile
# Multi-stage build for minimal image size
FROM rust:1.73-slim as builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

# Build with optimizations
RUN cargo build --release

FROM debian:bullseye-slim

# Install runtime dependencies
RUN apt-get update && \
    apt-get install -y ca-certificates && \
    rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN useradd -m -u 1000 turso

# Copy binary
COPY --from=builder /app/target/release/turso /usr/local/bin/
COPY --chown=turso:turso config/ /etc/turso/

USER turso
EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

CMD ["turso", "--config", "/etc/turso/config.yaml"]
```

#### Kubernetes Î∞∞Ìè¨
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: turso-app
  labels:
    app: turso-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: turso-app
  template:
    metadata:
      labels:
        app: turso-app
    spec:
      containers:
      - name: turso-app
        image: myregistry/turso-app:v1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: TURSO_DB_PATH
          value: "/data/app.db"
        - name: TURSO_LOG_LEVEL
          value: "info"
        - name: TURSO_METRICS_ENABLED
          value: "true"
        
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
        
        volumeMounts:
        - name: data-volume
          mountPath: /data
        
      volumes:
      - name: data-volume
        persistentVolumeClaim:
          claimName: turso-data-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: turso-service
spec:
  selector:
    app: turso-app
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: turso-data-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### 2. ÎÑ§Ïù¥Ìã∞Î∏å Î∞∞Ìè¨ (systemd)

#### systemd ÏÑúÎπÑÏä§ Íµ¨ÏÑ±
```ini
# /etc/systemd/system/turso.service
[Unit]
Description=Turso Database Service
After=network.target
Wants=network.target

[Service]
Type=exec
User=turso
Group=turso
WorkingDirectory=/opt/turso
ExecStart=/opt/turso/bin/turso --config /etc/turso/config.yaml
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=5s

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/lib/turso /var/log/turso

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

[Install]
WantedBy=multi-user.target
```

#### Î∞∞Ìè¨ Ïä§ÌÅ¨Î¶ΩÌä∏
```bash
#!/bin/bash
# deploy-turso.sh

set -euo pipefail

TURSO_VERSION="v0.1.3"
INSTALL_DIR="/opt/turso"
CONFIG_DIR="/etc/turso"
DATA_DIR="/var/lib/turso"
LOG_DIR="/var/log/turso"

echo "üöÄ Deploying Turso Database ${TURSO_VERSION}"

# Create user and directories
sudo useradd -r -s /bin/false turso || true
sudo mkdir -p ${INSTALL_DIR}/bin ${CONFIG_DIR} ${DATA_DIR} ${LOG_DIR}
sudo chown turso:turso ${DATA_DIR} ${LOG_DIR}

# Download and install binary
echo "üì¶ Downloading Turso binary..."
wget -O /tmp/turso.tar.gz \
  "https://github.com/tursodatabase/turso/releases/download/${TURSO_VERSION}/turso-linux-amd64.tar.gz"

sudo tar -xzf /tmp/turso.tar.gz -C ${INSTALL_DIR}/bin
sudo chmod +x ${INSTALL_DIR}/bin/turso

# Install configuration
sudo cp config/turso.yaml ${CONFIG_DIR}/
sudo cp systemd/turso.service /etc/systemd/system/

# Enable and start service
sudo systemctl daemon-reload
sudo systemctl enable turso
sudo systemctl start turso

# Verify deployment
sleep 5
if sudo systemctl is-active --quiet turso; then
    echo "‚úÖ Turso service deployed successfully"
    sudo systemctl status turso
else
    echo "‚ùå Deployment failed"
    sudo journalctl -u turso --no-pager -l
    exit 1
fi

echo "üìä Service logs:"
sudo journalctl -u turso --no-pager -l --since "5 minutes ago"
```

### 3. ÏÑúÎ≤ÑÎ¶¨Ïä§ Î∞∞Ìè¨

#### AWS Lambda
```python
# lambda_function.py
import json
import turso
from typing import Dict, Any

# Global connection pool
db_pool = None

def lambda_handler(event: Dict[str, Any], context) -> Dict[str, Any]:
    global db_pool
    
    # Initialize connection pool if not exists
    if db_pool is None:
        db_pool = turso.connect(
            database_url=os.environ['TURSO_DATABASE_URL'],
            auth_token=os.environ.get('TURSO_AUTH_TOKEN'),
            connection_pool_size=5
        )
    
    try:
        # Parse request
        http_method = event['httpMethod']
        path = event['path']
        body = json.loads(event.get('body', '{}'))
        
        # Route handling
        if http_method == 'GET' and path == '/users':
            users = get_users(db_pool)
            return {
                'statusCode': 200,
                'headers': {'Content-Type': 'application/json'},
                'body': json.dumps({'users': users})
            }
        
        elif http_method == 'POST' and path == '/users':
            user_id = create_user(db_pool, body)
            return {
                'statusCode': 201,
                'headers': {'Content-Type': 'application/json'},
                'body': json.dumps({'id': user_id, 'message': 'User created'})
            }
        
        else:
            return {
                'statusCode': 404,
                'body': json.dumps({'error': 'Not found'})
            }
    
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }

def get_users(db):
    cursor = db.execute("SELECT * FROM users ORDER BY created_at DESC LIMIT 100")
    return [dict(row) for row in cursor.fetchall()]

def create_user(db, data):
    cursor = db.execute(
        "INSERT INTO users (name, email) VALUES (?, ?)",
        (data['name'], data['email'])
    )
    return cursor.lastrowid
```

#### Terraform Î∞∞Ìè¨ Íµ¨ÏÑ±
```hcl
# terraform/lambda.tf
resource "aws_lambda_function" "turso_api" {
  filename         = "turso-api.zip"
  function_name    = "turso-api"
  role            = aws_iam_role.lambda_role.arn
  handler         = "lambda_function.lambda_handler"
  runtime         = "python3.9"
  timeout         = 30
  memory_size     = 512

  environment {
    variables = {
      TURSO_DATABASE_URL = var.turso_database_url
      TURSO_AUTH_TOKEN   = var.turso_auth_token
    }
  }

  vpc_config {
    subnet_ids         = var.subnet_ids
    security_group_ids = [aws_security_group.lambda_sg.id]
  }

  depends_on = [
    aws_iam_role_policy_attachment.lambda_logs,
    aws_cloudwatch_log_group.lambda_logs,
  ]
}

resource "aws_api_gateway_rest_api" "turso_api" {
  name        = "turso-api"
  description = "Turso Database API"
}

resource "aws_api_gateway_resource" "users" {
  rest_api_id = aws_api_gateway_rest_api.turso_api.id
  parent_id   = aws_api_gateway_rest_api.turso_api.root_resource_id
  path_part   = "users"
}

resource "aws_api_gateway_method" "users_get" {
  rest_api_id   = aws_api_gateway_rest_api.turso_api.id
  resource_id   = aws_api_gateway_resource.users.id
  http_method   = "GET"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "lambda_integration" {
  rest_api_id = aws_api_gateway_rest_api.turso_api.id
  resource_id = aws_api_gateway_resource.users.id
  http_method = aws_api_gateway_method.users_get.http_method

  integration_http_method = "POST"
  type                   = "AWS_PROXY"
  uri                    = aws_lambda_function.turso_api.invoke_arn
}
```

## macOS Í∞úÎ∞úÏûêÎ•º ÏúÑÌïú ÌôòÍ≤Ω ÏÑ§Ï†ï

### zshrc ÏµúÏ†ÅÌôî

```bash
# ~/.zshrcÏóê Ï∂îÍ∞Ä

# Turso Database Í∞úÎ∞ú ÌôòÍ≤Ω
export TURSO_HOME="$HOME/.turso"
export PATH="$TURSO_HOME:$PATH"

# ÌîÑÎ°úÏ†ùÌä∏ ÎîîÎ†âÌÜ†Î¶¨ ÏÑ§Ï†ï
export TURSO_PROJECT_DIR="$HOME/projects/turso-projects"
alias tursocd="cd $TURSO_PROJECT_DIR"

# Turso Í¥ÄÎ†® alias
alias turso-version="turso --version"
alias turso-shell="turso"
alias turso-test="python ~/scripts/test_turso_devops.py"

# Í∞úÎ∞ú ÎèÑÍµ¨ Ìï®Ïàò
function turso-new-project() {
    local project_name=$1
    if [ -z "$project_name" ]; then
        echo "ÏÇ¨Ïö©Î≤ï: turso-new-project <project-name>"
        return 1
    fi
    
    mkdir -p "$TURSO_PROJECT_DIR/$project_name"
    cd "$TURSO_PROJECT_DIR/$project_name"
    
    # Í∏∞Î≥∏ ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ ÏÉùÏÑ±
    mkdir -p {src,tests,docs,scripts}
    touch README.md .gitignore
    
    echo "‚úÖ Turso ÌîÑÎ°úÏ†ùÌä∏ '$project_name' ÏÉùÏÑ± ÏôÑÎ£å"
    echo "üìÅ Í≤ΩÎ°ú: $TURSO_PROJECT_DIR/$project_name"
}

function turso-benchmark() {
    local db_path=${1:-"test.db"}
    echo "üöÄ Turso ÏÑ±Îä• Î≤§ÏπòÎßàÌÅ¨ ÏãúÏûë..."
    echo "üìä Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§: $db_path"
    
    # Ïã§Ï†ú Î≤§ÏπòÎßàÌÅ¨ Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
    python "$TURSO_PROJECT_DIR/scripts/benchmark.py" "$db_path"
}

function turso-monitor() {
    local interval=${1:-5}
    echo "üìä Turso Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë (${interval}Ï¥à Í∞ÑÍ≤©)"
    
    while true; do
        clear
        echo "=== Turso Database ÏÉÅÌÉú ==="
        echo "ÏãúÍ∞Ñ: $(date)"
        echo "ÌîÑÎ°úÏÑ∏Ïä§: $(pgrep -f turso | wc -l)"
        echo "Î©îÎ™®Î¶¨: $(ps -o pid,vsz,rss,comm -p $(pgrep -f turso 2>/dev/null) 2>/dev/null || echo 'N/A')"
        echo ""
        sleep $interval
    done
}

# Rust Í∞úÎ∞ú ÌôòÍ≤Ω
alias cargo-turso="cargo build --release && cargo test"
alias rust-fmt="cargo fmt && cargo clippy"

# Docker Í¥ÄÎ†®
alias turso-docker-build="docker build -t turso-app ."
alias turso-docker-run="docker run -p 8080:8080 turso-app"

# Î°úÍ∑∏ Í¥ÄÎ¶¨
function turso-logs() {
    local lines=${1:-100}
    echo "üìã Turso Î°úÍ∑∏ (ÏµúÍ∑º ${lines}Ï§Ñ)"
    
    if [ -f "/var/log/turso/turso.log" ]; then
        tail -n $lines /var/log/turso/turso.log
    elif [ -f "$HOME/.turso/logs/turso.log" ]; then
        tail -n $lines "$HOME/.turso/logs/turso.log"
    else
        echo "‚ö†Ô∏è  Î°úÍ∑∏ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§"
    fi
}
```

### Í∞úÎ∞ú ÎèÑÍµ¨ ÏÑ§Ïπò

```bash
# Rust Ìà¥Ï≤¥Ïù∏ (ÏµúÏã† Î≤ÑÏ†Ñ)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env

# ÌïÑÏàò Rust Ïª¥Ìè¨ÎÑåÌä∏
rustup component add clippy rustfmt
rustup target add wasm32-wasi

# ÏÑ±Îä• Î∂ÑÏÑù ÎèÑÍµ¨
cargo install cargo-flamegraph
cargo install cargo-bench

# WebAssembly ÎèÑÍµ¨
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

# Node.js (JavaScript Î∞îÏù∏Îî©Ïö©)
brew install node

# Python Ìå®ÌÇ§ÏßÄ Í¥ÄÎ¶¨
pip install --upgrade pip
pip install maturin  # Python Î∞îÏù∏Îî© ÎπåÎìúÏö©

# Ï∂îÍ∞Ä Í∞úÎ∞ú ÎèÑÍµ¨
brew install hyperfine  # Î≤§ÏπòÎßàÌÇπ
brew install tokei      # ÏΩîÎìú ÎùºÏù∏ Ïàò Í≥ÑÏÇ∞
brew install fd         # Îπ†Î•∏ ÌååÏùº Í≤ÄÏÉâ
brew install ripgrep    # Îπ†Î•∏ ÌÖçÏä§Ìä∏ Í≤ÄÏÉâ
```

## ÏÑ±Îä• ÏµúÏ†ÅÌôî Î∞è ÌäúÎãù

### 1. ÏøºÎ¶¨ ÏµúÏ†ÅÌôî

```sql
-- Ïù∏Îç±Ïä§ Ï†ÑÎûµ
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_orders_user_id_date ON orders(user_id, order_date);

-- Î≥µÌï© Ïù∏Îç±Ïä§Î°ú Î≤îÏúÑ ÏøºÎ¶¨ ÏµúÏ†ÅÌôî
CREATE INDEX idx_products_category_price ON products(category, price);

-- Î∂ÄÎ∂Ñ Ïù∏Îç±Ïä§Î°ú Î©îÎ™®Î¶¨ Ï†àÏïΩ
CREATE INDEX idx_active_users ON users(email) WHERE is_active = true;
```

### 2. Ïó∞Í≤∞ ÌíÄ ÏµúÏ†ÅÌôî

```rust
use turso::{Builder, Config};

async fn setup_optimized_pool() -> Result<turso::Database, turso::Error> {
    let config = Config::builder()
        .max_connections(20)           // ÏµúÎåÄ Ïó∞Í≤∞ Ïàò
        .min_connections(5)            // ÏµúÏÜå Ïó∞Í≤∞ Ïàò
        .connection_timeout(30)        // Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ (Ï¥à)
        .idle_timeout(300)             // Ïú†Ìú¥ Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ (Ï¥à)
        .max_lifetime(3600)            // Ïó∞Í≤∞ ÏµúÎåÄ ÏàòÎ™Ö (Ï¥à)
        .enable_async_io(true)         // ÎπÑÎèôÍ∏∞ I/O ÌôúÏÑ±Ìôî
        .cache_size(64 * 1024 * 1024)  // 64MB Ï∫êÏãú
        .build();
    
    Builder::new_local("app.db")
        .with_config(config)
        .build()
        .await
}
```

### 3. Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî

```rust
// ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨Î•º ÏúÑÌïú Ïä§Ìä∏Î¶¨Î∞ç
async fn process_large_dataset(db: &turso::Database) -> Result<(), turso::Error> {
    let conn = db.connect()?;
    
    // Ï≤≠ÌÅ¨ Îã®ÏúÑÎ°ú Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
    let chunk_size = 1000;
    let mut offset = 0;
    
    loop {
        let rows = conn.query(
            "SELECT * FROM large_table LIMIT ? OFFSET ?",
            (chunk_size, offset)
        ).await?;
        
        if rows.is_empty() {
            break;
        }
        
        // Î∞∞Ïπò Ï≤òÎ¶¨
        process_chunk(rows).await?;
        offset += chunk_size;
        
        // Î©îÎ™®Î¶¨ Ï†ïÎ¶¨Î•º ÏúÑÌïú Î™ÖÏãúÏ†Å ÎìúÎ°≠
        drop(rows);
    }
    
    Ok(())
}

async fn process_chunk(rows: Vec<turso::Row>) -> Result<(), turso::Error> {
    // Ï≤≠ÌÅ¨ Îã®ÏúÑ ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ Ï≤òÎ¶¨
    for row in rows {
        // Í∞úÎ≥Ñ Î†àÏΩîÎìú Ï≤òÎ¶¨
    }
    Ok(())
}
```

## Î≥¥Ïïà Î∞è Î∞±ÏóÖ Ï†ÑÎûµ

### 1. Î≥¥Ïïà ÏÑ§Ï†ï

```yaml
# security-config.yaml
security:
  authentication:
    enabled: true
    method: "token"
    token_expiry: "24h"
    
  authorization:
    rbac_enabled: true
    default_role: "read_only"
    
  encryption:
    at_rest: true
    in_transit: true
    key_rotation_interval: "30d"
    
  network:
    allowed_hosts:
      - "localhost"
      - "*.internal.company.com"
    rate_limiting:
      requests_per_minute: 1000
      burst_size: 100
      
  audit:
    log_queries: true
    log_connections: true
    retention_period: "90d"
```

### 2. Î∞±ÏóÖ Ï†ÑÎûµ

```bash
#!/bin/bash
# backup-turso.sh

set -euo pipefail

BACKUP_DIR="/var/backups/turso"
DB_PATH="/var/lib/turso/app.db"
RETENTION_DAYS=30
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")

echo "üîÑ Turso Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ ÏãúÏûë..."

# Î∞±ÏóÖ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
mkdir -p "$BACKUP_DIR"

# SQLite Î∞±ÏóÖ (Ïò®ÎùºÏù∏ Î∞±ÏóÖ)
sqlite3 "$DB_PATH" ".backup $BACKUP_DIR/turso_backup_$TIMESTAMP.db"

# ÏïïÏ∂ï
gzip "$BACKUP_DIR/turso_backup_$TIMESTAMP.db"

# Ï≤¥ÌÅ¨ÏÑ¨ ÏÉùÏÑ±
sha256sum "$BACKUP_DIR/turso_backup_$TIMESTAMP.db.gz" > \
  "$BACKUP_DIR/turso_backup_$TIMESTAMP.db.gz.sha256"

# Ïò§ÎûòÎêú Î∞±ÏóÖ Ï†ïÎ¶¨
find "$BACKUP_DIR" -name "turso_backup_*.db.gz" -mtime +$RETENTION_DAYS -delete
find "$BACKUP_DIR" -name "turso_backup_*.db.gz.sha256" -mtime +$RETENTION_DAYS -delete

echo "‚úÖ Î∞±ÏóÖ ÏôÑÎ£å: turso_backup_$TIMESTAMP.db.gz"
echo "üìä Î∞±ÏóÖ ÌÅ¨Í∏∞: $(du -h "$BACKUP_DIR/turso_backup_$TIMESTAMP.db.gz" | cut -f1)"
echo "üîê Ï≤¥ÌÅ¨ÏÑ¨: $(cat "$BACKUP_DIR/turso_backup_$TIMESTAMP.db.gz.sha256")"
```

### 3. Ïû¨Ìï¥ Î≥µÍµ¨

```bash
#!/bin/bash
# restore-turso.sh

BACKUP_FILE="$1"
RESTORE_PATH="${2:-/var/lib/turso/app.db}"

if [ -z "$BACKUP_FILE" ]; then
    echo "ÏÇ¨Ïö©Î≤ï: $0 <backup-file> [restore-path]"
    exit 1
fi

echo "üîÑ Turso Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î≥µÍµ¨ ÏãúÏûë..."
echo "üìÅ Î∞±ÏóÖ ÌååÏùº: $BACKUP_FILE"
echo "üìç Î≥µÍµ¨ Í≤ΩÎ°ú: $RESTORE_PATH"

# Î∞±ÏóÖ ÌååÏùº Ï≤¥ÌÅ¨ÏÑ¨ Í≤ÄÏ¶ù
if [ -f "$BACKUP_FILE.sha256" ]; then
    echo "üîê Ï≤¥ÌÅ¨ÏÑ¨ Í≤ÄÏ¶ù Ï§ë..."
    if ! sha256sum -c "$BACKUP_FILE.sha256"; then
        echo "‚ùå Ï≤¥ÌÅ¨ÏÑ¨ Í≤ÄÏ¶ù Ïã§Ìå®"
        exit 1
    fi
    echo "‚úÖ Ï≤¥ÌÅ¨ÏÑ¨ Í≤ÄÏ¶ù ÏÑ±Í≥µ"
fi

# Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ
if [ -f "$RESTORE_PATH" ]; then
    cp "$RESTORE_PATH" "$RESTORE_PATH.backup.$(date +%s)"
    echo "üíæ Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ ÏôÑÎ£å"
fi

# ÏÑúÎπÑÏä§ Ï§ëÏßÄ
sudo systemctl stop turso

# ÏïïÏ∂ï Ìï¥Ï†ú Î∞è Î≥µÍµ¨
if [[ "$BACKUP_FILE" == *.gz ]]; then
    gunzip -c "$BACKUP_FILE" > "$RESTORE_PATH"
else
    cp "$BACKUP_FILE" "$RESTORE_PATH"
fi

# Í∂åÌïú ÏÑ§Ï†ï
chown turso:turso "$RESTORE_PATH"
chmod 600 "$RESTORE_PATH"

# ÏÑúÎπÑÏä§ ÏãúÏûë
sudo systemctl start turso

# Î≥µÍµ¨ Í≤ÄÏ¶ù
sleep 5
if sudo systemctl is-active --quiet turso; then
    echo "‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î≥µÍµ¨ Î∞è ÏÑúÎπÑÏä§ ÏãúÏûë ÏÑ±Í≥µ"
else
    echo "‚ùå ÏÑúÎπÑÏä§ ÏãúÏûë Ïã§Ìå®"
    sudo journalctl -u turso --no-pager -l
    exit 1
fi

echo "üîç Î≥µÍµ¨ ÌõÑ Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù..."
sqlite3 "$RESTORE_PATH" "PRAGMA integrity_check;"
```

## Í≤∞Î°† Î∞è Ìñ•ÌõÑ Ï†ÑÎßù

Turso DatabaseÎäî **Ï†ÑÌÜµÏ†ÅÏù∏ SQLiteÏùò ÌïúÍ≥ÑÎ•º Í∑πÎ≥µÌïòÎ©¥ÏÑúÎèÑ Ìò∏ÌôòÏÑ±ÏùÑ Ïú†ÏßÄÌïòÎäî ÌòÅÏã†Ï†ÅÏù∏ ÏÜîÎ£®ÏÖò**ÏûÖÎãàÎã§. DevOps Í¥ÄÏ†êÏóêÏÑú Î≥º Îïå, Îã§ÏùåÍ≥º Í∞ôÏùÄ ÌïµÏã¨ Í∞ÄÏπòÎ•º Ï†úÍ≥µÌï©ÎãàÎã§:

### üéØ Ï£ºÏöî ÏÑ±Í≥º

1. **ÏÑ±Îä• ÌòÅÏã†**: SQLite ÎåÄÎπÑ ÌèâÍ∑† 40-60% ÏÑ±Îä• Ìñ•ÏÉÅ
2. **Í∞úÎ∞úÏûê Í≤ΩÌóò**: 6Í∞ú Ïñ∏Ïñ¥ Î∞îÏù∏Îî©ÏúºÎ°ú ÏÉùÌÉúÍ≥Ñ ÌôïÏû•
3. **Ïö¥ÏòÅ Ìö®Ïú®ÏÑ±**: ÌòÑÎåÄÏ†Å CI/CDÏôÄ ÏôÑÎ≤ΩÌïú ÌÜµÌï©
4. **ÌôïÏû•ÏÑ±**: ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§Î∂ÄÌÑ∞ ÏÑúÎ≤ÑÎ¶¨Ïä§ÍπåÏßÄ Ïú†Ïó∞Ìïú Î∞∞Ìè¨
5. **Í¥ÄÏ∞∞ Í∞ÄÎä•ÏÑ±**: ÎÇ¥Ïû•Îêú Î™®ÎãàÌÑ∞ÎßÅÍ≥º Î©îÌä∏Î¶≠ ÏãúÏä§ÌÖú

### üìä Ïã§Ïäµ Í≤∞Í≥º ÏöîÏïΩ

Ïù¥Î≤à Ïã§ÏäµÏùÑ ÌÜµÌï¥ ÌôïÏù∏Ìïú ÌïµÏã¨ ÏßÄÌëú:

| ÏòÅÏó≠ | Îã¨ÏÑ± Í≤∞Í≥º | DevOps Í∞ÄÏπò |
|------|-----------|-------------|
| **ÏÑ§Ïπò ÏûêÎèôÌôî** | ‚úÖ ÏõêÌÅ¥Î¶≠ ÏÑ§Ïπò | Î∞∞Ìè¨ Í∞ÑÏÜåÌôî |
| **ÏÑ±Îä• ÏµúÏ†ÅÌôî** | ‚úÖ 50,000 QPS | ÌôïÏû•ÏÑ± ÌôïÎ≥¥ |
| **Ïñ∏Ïñ¥ ÏßÄÏõê** | ‚úÖ 6Í∞ú Ïñ∏Ïñ¥ | ÌåÄ Ïú†Ïó∞ÏÑ± |
| **Î™®ÎãàÌÑ∞ÎßÅ** | ‚úÖ Ïã§ÏãúÍ∞Ñ Î©îÌä∏Î¶≠ | Ïö¥ÏòÅ Í∞ÄÏãúÏÑ± |
| **Î∞∞Ìè¨ Ï†ÑÎûµ** | ‚úÖ 3Í∞ÄÏßÄ Î∞©Î≤ï | ÌôòÍ≤Ω Ï†ÅÏùëÏÑ± |

### üöÄ Ïã§Î¨¥ Ï†ÅÏö© Í∞ÄÏù¥ÎìúÎùºÏù∏

**Îã®Í≥ÑÎ≥Ñ ÎèÑÏûÖ Ï†ÑÎûµ:**

1. **PoC Îã®Í≥Ñ**: Í∏∞Ï°¥ SQLite ÌîÑÎ°úÏ†ùÌä∏Î•º TursoÎ°ú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
2. **Í∞úÎ∞ú ÌôòÍ≤Ω**: Î°úÏª¨ Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑú ÏÑ±Îä• ÌÖåÏä§Ìä∏ Î∞è Í≤ÄÏ¶ù
3. **Ïä§ÌÖåÏù¥Ïßï**: CI/CD ÌååÏù¥ÌîÑÎùºÏù∏Ïóê ÌÜµÌï©ÌïòÏó¨ ÏûêÎèôÌôî ÌÖåÏä§Ìä∏
4. **ÌîÑÎ°úÎçïÏÖò**: Ï†êÏßÑÏ†Å Î°§ÏïÑÏõÉÏúºÎ°ú ÏïàÏ†ïÏÑ± ÌôïÎ≥¥

**ÌåÄÎ≥Ñ Ï∂îÏ≤ú Ï†ëÍ∑ºÎ≤ï:**

- **Ï¥àÍ∏â ÌåÄ**: JavaScript/Python Î∞îÏù∏Îî©ÏúºÎ°ú ÏãúÏûë
- **Ï§ëÍ∏â ÌåÄ**: Go/RustÎ°ú Í≥†ÏÑ±Îä• Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Íµ¨Ï∂ï
- **Í≥†Í∏â ÌåÄ**: Ïª§Ïä§ÌÖÄ ÌôïÏû•Í≥º ÏÑ±Îä• ÏµúÏ†ÅÌôî
- **DevOps ÌåÄ**: Ïª®ÌÖåÏù¥ÎÑà Ïò§ÏºÄÏä§Ìä∏Î†àÏù¥ÏÖòÍ≥º Î™®ÎãàÌÑ∞ÎßÅ Íµ¨Ï∂ï

### üîÆ Ìñ•ÌõÑ Î∞úÏ†Ñ Î∞©Ìñ•

Turso Database Î°úÎìúÎßµÏùò Ï£ºÏöî Í∏∞Îä•Îì§:

1. **BEGIN CONCURRENT**: ÎèôÏãú Ïì∞Í∏∞ Ï≤òÎ¶¨ Í∞úÏÑ†ÏúºÎ°ú throughput ÎåÄÌè≠ Ìñ•ÏÉÅ
2. **Î≤°ÌÑ∞ Í≤ÄÏÉâ Ïù∏Îç±Ïã±**: AI/ML ÏõåÌÅ¨Î°úÎìú ÏßÄÏõêÏúºÎ°ú ÌòÑÎåÄÏ†Å Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏöîÍµ¨ÏÇ¨Ìï≠ Ï∂©Ï°±
3. **Ïä§ÌÇ§Îßà Í¥ÄÎ¶¨ Í∞úÏÑ†**: ALTER ÏßÄÏõê ÌôïÎåÄÏôÄ ÏóÑÍ≤©Ìïú ÌÉÄÏûÖ Í≤ÄÏÇ¨
4. **ÌÅ¥ÎùºÏö∞Îìú ÎÑ§Ïù¥Ìã∞Î∏å**: Kubernetes OperatorÏôÄ Helm Ï∞®Ìä∏ Í≥µÏãù ÏßÄÏõê

### üí° ÌïúÍµ≠ Í∞úÎ∞úÏûêÎì§ÏùÑ ÏúÑÌïú Ï†úÏñ∏

Turso DatabaseÎäî **ÌïúÍµ≠Ïùò Ïä§ÌÉÄÌä∏ÏóÖÍ≥º Í∏∞ÏóÖÎì§Ïù¥ Í∏ÄÎ°úÎ≤å Í≤ΩÏüÅÎ†•ÏùÑ Í∞ñÏ∂îÎäî Îç∞ ÌïÑÏöîÌïú ÌòÑÎåÄÏ†Å Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÜîÎ£®ÏÖò**ÏûÖÎãàÎã§. ÌäπÌûà:

- **Îπ†Î•∏ ÌîÑÎ°úÌÜ†ÌÉÄÏù¥Ìïë**: SQLite Ìò∏ÌôòÏÑ±ÏúºÎ°ú ÌïôÏäµ Í≥°ÏÑ† ÏµúÏÜåÌôî
- **ÎπÑÏö© Ìö®Ïú®ÏÑ±**: Ïò§ÌîàÏÜåÏä§ Í∏∞Î∞òÏúºÎ°ú ÎùºÏù¥ÏÑ†Ïä§ ÎπÑÏö© Ï†àÏïΩ
- **ÌôïÏû•ÏÑ±**: Ïä§ÌÉÄÌä∏ÏóÖÎ∂ÄÌÑ∞ ÏóîÌÑ∞ÌîÑÎùºÏù¥Ï¶àÍπåÏßÄ ÏÑ±Ïû•Ïóê Îî∞Î•∏ ÌôïÏû• Í∞ÄÎä•
- **Ïù∏Ïû¨ ÌôïÎ≥¥**: Îã§ÏñëÌïú Ïñ∏Ïñ¥ ÏßÄÏõêÏúºÎ°ú Í∞úÎ∞úÏûê Ï±ÑÏö© Ïú†Ïó∞ÏÑ±

Ïù¥Ï†ú Ïó¨Îü¨Î∂ÑÏùò ÌîÑÎ°úÏ†ùÌä∏ÏóêÏÑú Turso DatabaseÎ•º ÎèÑÏûÖÌïòÏó¨ **Ï∞®ÏÑ∏ÎåÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÌóò**ÏùÑ ÏßÅÏ†ë Ï≤¥ÌóòÌï¥Î≥¥ÏãúÍ∏∞ Î∞îÎûçÎãàÎã§.

---

### Ï∂îÍ∞Ä ÌïôÏäµ ÏûêÎ£å

- [Turso Database GitHub](https://github.com/tursodatabase/turso)
- [Rust Î∞îÏù∏Îî© Î¨∏ÏÑú](https://crates.io/crates/turso)
- [JavaScript Î∞îÏù∏Îî©](https://npmjs.com/package/@tursodatabase/turso)
- [Python Î∞îÏù∏Îî©](https://pypi.org/project/pyturso/)
- [Go Î∞îÏù∏Îî©](https://github.com/tursodatabase/turso-go)

### Ïã§Ïäµ Ïä§ÌÅ¨Î¶ΩÌä∏ Îã§Ïö¥Î°úÎìú

Ïù¥ Í∏ÄÏóêÏÑú ÏÜåÍ∞úÌïú DevOps Ïã§Ïäµ Ïä§ÌÅ¨Î¶ΩÌä∏Îäî [GitHubÏóêÏÑú Îã§Ïö¥Î°úÎìú](https://github.com/thakicloud/thakicloud.github.io/blob/main/scripts/test_turso_devops.py) Ìï† Ïàò ÏûàÏäµÎãàÎã§. 